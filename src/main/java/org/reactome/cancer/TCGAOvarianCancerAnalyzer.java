/*
 * Created on May 1, 2009
 *
 */
package org.reactome.cancer;

import java.awt.Color;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.math.random.RandomData;
import org.apache.commons.math.random.RandomDataImpl;
import org.apache.commons.math.stat.inference.TestUtils;
import org.junit.Test;
import org.reactome.annotate.AnnotationType;
import org.reactome.annotate.PathwayBasedAnnotator;
import org.reactome.cancer.base.MATFileLoader;
import org.reactome.hibernate.HibernateFIReader;
import org.reactome.r3.TopicAnalyzer;
import org.reactome.r3.UCSCDataAnalyzer;
import org.reactome.r3.cluster.HierarchicalCluster;
import org.reactome.r3.cluster.HierarchicalClusterNode;
import org.reactome.r3.fi.SurvivalAnalysisHelper;
import org.reactome.r3.fi.SurvivalAnalysisResult;
import org.reactome.r3.graph.BreadthFirstSearch;
import org.reactome.r3.graph.GraphAnalyzer;
import org.reactome.r3.graph.SpectralPartitionNetworkCluster;
import org.reactome.r3.util.FileUtility;
import org.reactome.r3.util.FisherExact;
import org.reactome.r3.util.InteractionUtilities;
import org.reactome.r3.util.MathUtilities;
import org.reactome.r3.util.R3Constants;

public class TCGAOvarianCancerAnalyzer extends CancerResequenceDataSetAnalyzer {
    // Gene exp file generated by the TCGA group
    //private final String GENE_EXP_FILE = OVARIAN_DIR_NAME + "GeneExp090209/ovUnifiedScaledQualityFiltered_20090902_fixed.txt";
    //private final String GENE_EXP_FILE = OVARIAN_DIR_NAME + "data_110609/TCGA_Batch9-15_median_Symbol_excluded_na_removed.txt";
//    private final String GENE_EXP_FILE = OVARIAN_DIR_NAME + "data_072610/TCGA_batch9-15_17-19_21-22_24.UE.txt";
    private final String GENE_EXP_FILE = OVARIAN_DIR_NAME + "data_072610/TCGA_batch9-15_17-19_21-22_24.UE.No_Normal.txt";
    //private final String MUTATION_FILE = OVARIAN_DIR_NAME + "data_110609/TCGA_OV_Capture_Exchange_Consolidated_wustl_bcm_broad.wustl_annotation.18feb2010d.txt";
    //private final String MUTATION_FILE = OVARIAN_DIR_NAME + "data_031910/mutations/TCGA_OV_Capture_Exchange_Consolidated_wustl_bcm_broad.wustl_annotation.11mar2010u.maf_filtered.txt";
    //private String MUTATION_FILE = OVARIAN_DIR_NAME + "data_072610/TCGA_OV_EXOME_CAPTURE_THREE_CENTER_MAF.070910.tsv";
//    private String MUTATION_FILE = OVARIAN_DIR_NAME + "data_072610/TCGA_OV_EXOME_CAPTURE_THREE_CENTER_Somatic_BRCA1_2_Germline.083110.maf";
//    private String MUTATION_FILE = OVARIAN_DIR_NAME + "data_published_in_nature/2010-09-11380C-Table_S2.1_20110113.txt";
    private String MUTATION_FILE = OVARIAN_DIR_NAME + "FireHose/gdac.broadinstitute.org_OV.Mutation_Significance.Level_4.2012072500.0.0/OV.final_analysis_set.maf";
//    private String MUTATION_FILE = OVARIAN_DIR_NAME + "data_published_in_nature/2010-09-11380C-Table_S2.1_20110113_with_edit.txt";
    // Used as a validation for batch 17-19
    //private final String GENE_EXP_FILE = OVARIAN_DIR_NAME + "data_110609/TCGA_17-19_median.txt";
    //private final String SEQUENCE_SAMPLE_FILE = OVARIAN_DIR_NAME + "data_031910/SampleList/sequenced_3_16_2010.txt";
    private String SEQUENCE_SAMPLE_FILE = OVARIAN_DIR_NAME + "data_072610/TCGA_OV_EXOME_CAPTURE_SAMPLE_LIST.071610.txt";
    
    public TCGAOvarianCancerAnalyzer() {
    }
    
    @Test
    public void quickFixHeaders() throws IOException {
        String inFileName = OVARIAN_DIR_NAME + "data_072610/TCGA_batch9-15_17-19_21-22_24.UE.No_Normal.txt";
        fu.setInput(inFileName);
        String line = fu.readLine();
        String[] tokens = line.split("\t");
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < tokens.length; i++) {
            if (i == 0) {
                builder.append(tokens[i]);
                continue;
            }
            System.out.println(tokens[i]);
            String[] tmp = tokens[i].split("\\.");
            String id = "";
            for (int j = 0; j < 3; j++) {
                id += tmp[j];
                if (j < 2)
                    id += "-";
            }
            builder.append("\t").append(id);
        }
        System.out.println(builder.toString());
        fu.close();
    }
    
    @Test
    public void compareGeneExpToNetworkModules() throws Exception {
        Map<String, Map<String, Double>> geneToSampleToValue = loadGeneExp();
        // Need to switch to sampleToGeneToValue 
        Map<String, Map<String, Double>> sampleToGeneToValue = new HashMap<String, Map<String,Double>>();
        for (String gene : geneToSampleToValue.keySet()) {
            Map<String, Double> sampleToValue = geneToSampleToValue.get(gene);
            for (String sample : sampleToValue.keySet()) {
                Map<String, Double> geneToValue = sampleToGeneToValue.get(sample);
                if (geneToValue == null) {
                    geneToValue = new HashMap<String, Double>();
                    sampleToGeneToValue.put(sample, geneToValue);
                }
                geneToValue.put(gene, sampleToValue.get(sample));
            }
        }
        
        String fileName = OVARIAN_DIR_NAME + "ClustersForTTestGenesBatch9_15.txt";
        NetworkClusterAnalyzer clusterAnalyzer = new NetworkClusterAnalyzer();
        List<Set<String>> clusters = clusterAnalyzer.loadNetworkClusters(fileName);
        fileName = OVARIAN_DIR_NAME + "TCGA_Batch9-15_median_t_stat.txt";
        Map<String, Double> geneToTStat = RUtilities.loadGeneToValue(fileName, 1);
        Map<String, Double> geneToPValue = RUtilities.loadGeneToValue(fileName, 2);
        int index = 0;
        for (Set<String> cluster : clusters) {
            if (cluster.size() < 10)
                continue;
            System.out.println("\ncluster " + index);
            // Generate a signature
            Set<String> signature = new HashSet<String>();
            for (String gene : cluster) {
                System.out.println(gene + "\t" + geneToTStat.get(gene) + "\t" +
                                   geneToPValue.get(gene));
                if (geneToPValue.get(gene) <= 0.05)
                    signature.add(gene);
            }
            List<Double> signatureExp = new ArrayList<Double>();
            for (String gene : signature) {
                if (geneToTStat.get(gene) < 0)
                    signatureExp.add(-1.0);
                else
                    signatureExp.add(1.0);
            }
            for (String sample : sampleToGeneToValue.keySet()) {
                Map<String, Double> geneToExp = sampleToGeneToValue.get(sample);
                List<Double> geneExps = new ArrayList<Double>();
                for (String gene : signature) {
                    Double value = geneToExp.get(gene);
                    if (value == null) {
                        System.out.println(sample + " has no value for " + gene);
                    }
                    geneExps.add(value);
                }
                double cor = MathUtilities.calculatePearsonCorrelation(signatureExp, 
                                                                       geneExps);
                System.out.println(sample + "\t" + cor);
            }
            index ++;
        }
    }
    
    @Test
    public void permutateAlteredGeneModules() throws Exception {
        Map<String, Set<String>> sampleToAlteredGenes = loadSampleToNonSynonymousMutatedGenes(false);
        filterSampleToGenes(sampleToAlteredGenes, 2);
        NetworkClusterAnalyzer cluster = new NetworkClusterAnalyzer();
        cluster.permutationTestBasedOnModularity(sampleToAlteredGenes);
    }
    
    @Test
    public void generateSampleToMutatedGenesInModules() throws Exception {
        Set<String> moduleGenes = fu.loadInteractions(OVARIAN_DIR_NAME + "data_published_in_nature/GenesInModules6And7.txt");
        Map<String, Set<String>> sampleToGenes = loadSampleToNonSynonymousMutatedGenes(false);
        System.out.println("Total module genes: " + moduleGenes.size());
        System.out.println("Total samples: " + sampleToGenes.size());
        String outFileName = OVARIAN_DIR_NAME + "data_published_in_nature/SampleToModule6And7Genes.txt";
        
        NetworkClusterAnalyzer analyzer = new NetworkClusterAnalyzer();
        analyzer.generateSampleToSelectedGenesMatrix(sampleToGenes, 
                                                     moduleGenes,
                                                     outFileName);
    }
    
    /**
     * Use this method to do a random permutation and pick up the best mutation module from randomly
     * generated gene set in order to see overlapping between the random modules and original TCGA
     * OV exome module.
     * @throws Exception
     */
    @Test
    public void randomSearchBestMutationModules() throws Exception {
        Map<String, Set<String>> sampleToGenes = loadSampleToNonSynonymousMutatedGenes(false);
        List<String> sampleList = new ArrayList<String>(sampleToGenes.keySet());
        Set<String> pickedSamples = MathUtilities.randomSampling(sampleList, 9 * sampleList.size() / 10);
        sampleToGenes.keySet().retainAll(pickedSamples);
        System.out.println("Total samples: " + sampleToGenes.size());
        filterSampleToGenes(sampleToGenes, 3);
        Set<String> geneSet = InteractionUtilities.grepAllGenes(sampleToGenes);
        System.out.println("Total genes: " + geneSet.size());

        Set<String> allFIs = fu.loadInteractions(R3Constants.GENE_FI_FILE_NAME);
        Set<String> totalGenes = InteractionUtilities.grepIDsFromInteractions(allFIs);
        Set<String> fis = InteractionUtilities.getFIs(geneSet, allFIs);
        
        List<Set<String>> modules = new SpectralPartitionNetworkCluster().cluster(fis);
        System.out.println("Total modules: " + modules.size());
        
        String clinFileName = OVARIAN_DIR_NAME + "FireHose/gdac.broadinstitute.org_OV.Clinical_Pick_Tier1.Level_4.2012082500.0.0/OV.clin.transformed.txt";
        
        SurvivalAnalysisHelper helper = CancerAnalysisUtilitites.getSurvivalAnalysisHelper();
        Double targetPValue = 1.0d;
        for (int i = 0; i < modules.size(); i++) {        
            Set<String> module = modules.get(i);
            if (module.size() < 5)
                continue;
            SurvivalAnalysisResult result = doSurvivalAnalysisForMutationModule(helper,
                                                                                sampleToGenes,
                                                                                module,
                                                                                clinFileName, 
                                                                                "TCGA_OV_Module_",
                                                                                "coxph");
           Double pvalue = extractPValueFromSurvivalResult(result);
           System.out.println(i + "\t" + module.size() + "\t" + pvalue);
           if (pvalue < targetPValue)
               targetPValue = pvalue;
        }
        if (true)
            return;
        // We should choose module 3, which has the lowest p-value based on a pre-run
        Set<String> pickedModule = modules.get(3);
        
        int targetSize = pickedModule.size();
        int permutation = 1000;
        
        // Want to check the same set of genes
        Set<String> targetGenes = InteractionUtilities.grepIDsFromInteractions(fis);
        System.out.println("Target size: " + targetSize + " from " + targetGenes.size() + " for target pvalue " + targetPValue);
        System.out.println("\nStart random searching...");
        List<Set<String>> bestRandomModules = new ArrayList<Set<String>>();
        
        for (int j = 0; j < 10; j++) {
            System.out.println("Random test " + j);
            // Used to calculate p-values
            List<Double> pvalues = new ArrayList<Double>();
            RandomData randomizer = new RandomDataImpl(); // Use a different randomizer in order to avoid duplication
            Set<String> bestRandomModule = null;
            double lowestPValue = Double.MAX_VALUE;
            for (int i = 0; i < permutation; i++) {
                Set<String> randomSet = MathUtilities.randomSampling(targetGenes, 
                                                                     targetSize, 
                                                                     randomizer);
                SurvivalAnalysisResult result = doSurvivalAnalysisForMutationModule(helper,
                                                                                    sampleToGenes,
                                                                                    randomSet,
                                                                                    clinFileName, 
                                                                                    "TCGA_OV_Module_",
                                                                                    "coxph");
                Double pvalue = extractPValueFromSurvivalResult(result);
                //           System.out.println(i + "\t" + pvalue);
                if (pvalue == null)
                    pvalue = 1.0d; // Assign the highest
                if (pvalue < lowestPValue) {
                    lowestPValue = pvalue;
                    bestRandomModule = randomSet;
                }
                pvalues.add(pvalue);
            }
            Collections.sort(pvalues);
            System.out.println("Best pvalue: " + lowestPValue);
            System.out.println("Best module: " + bestRandomModule);
            // Calculate nominal p-value
            int index = 0;
            for (int i = 0; i < pvalues.size(); i++) {
                Double pvalue = pvalues.get(i);
                if (pvalue <= targetPValue) {
                    index ++;
                }
                else
                    break;
            }
            System.out.println("Nominal p-value: " + (double)index / permutation);
            
            // Check overlapping
            Set<String> shared = InteractionUtilities.getShared(pickedModule,
                                                                bestRandomModule);
            Double pvalue = MathUtilities.calculateHypergeometricPValue(targetGenes.size(),
                                                                        pickedModule.size(), 
                                                                        bestRandomModule.size(),
                                                                        shared.size());
            System.out.println("Overlapping (" + shared.size() + "): " + shared);
            System.out.println("Pvalue: " + pvalue);
            System.out.println();
            bestRandomModules.add(bestRandomModule);
        }
        System.out.println("\nBest 10 random modules:");
        for (Set<String> set : bestRandomModules) {
            System.out.println(InteractionUtilities.joinStringElements(",", set));
        }
    }
    
    private Double extractPValueFromSurvivalResult(SurvivalAnalysisResult result) {
        if (result == null)
            return null;
        String[] lines = result.getOutput().split("\n");
        for (String line : lines) {
            if (line.startsWith("Wald test")) {
                int index = line.indexOf("p=");
                String pvalue = line.substring(index + 2).trim();
                return new Double(pvalue);
            }
        }
        return null;
    }
    
    /**
     * Randomly generate gene sets, generate sample to gene set mappings.
     * @throws Exception
     */
    @Test
    public void permutateNetworkModulesForSamples() throws Exception {
//        Map<String, Set<String>> sampleToGenes = loadSampleToNonSynonymousMutatedGenes(false);
        // for FireHose GBM data
        String dirName = "datasets/TCGA/GBM/FireHose/";
        String fileName = dirName + "FH_GBM.Mutation_Significance.Level_4.20120725/GBM.final_analysis_set.maf";
        Map<String, Set<String>> sampleToGenes = new MATFileLoader().loadSampleToGenes(fileName, false);
        filterSampleToGenes(sampleToGenes, 5);
        
//        filterSampleToGenes(sampleToGenes, 3);
        Set<String> geneSet = InteractionUtilities.grepAllGenes(sampleToGenes);
        System.out.println("Total genes: " + geneSet.size());

        Set<String> allFIs = fu.loadInteractions(R3Constants.GENE_FI_FILE_NAME);
        Set<String> fis = InteractionUtilities.getFIs(geneSet, allFIs);
        // Want to get the biggest component
        GraphAnalyzer graphAnalyzer = new GraphAnalyzer();
        List<Set<String>> components = graphAnalyzer.calculateGraphComponents(fis);
        for (int i = 0; i < components.size(); i++) {
            Set<String> component = components.get(i);
            System.out.println(i + ": " + component.size());
        }
        // Use the largest component
        geneSet = components.get(0);
        fis = InteractionUtilities.getFIs(geneSet, fis);
        Map<String, Set<String>> geneToPartners = new BreadthFirstSearch().generateIdToPartnersMap(fis);
//        if (true)
//            return;
//        // Target size of gene set
////        int targetSize = 60;
////        int targetSize = 48;
//        int targetSize = 43;
        
        int targetSize = 23;
        int permutation = 1000;
        RandomData randomizer = new RandomDataImpl();
//        String output = OVARIAN_DIR_NAME  + "SampleToRandomGeneSet_RandomWalk_091410.txt";
//        String output = OVARIAN_DIR_NAME + "data_published_in_nature/SampleToRandomGeneSet_101411.txt";
//        String output = OVARIAN_DIR_NAME + "data_published_in_nature/SampleToRandomGeneSet_Big_Comp_101411.txt";
//        String output = OVARIAN_DIR_NAME + "data_published_in_nature/SampleToRandomWalkGeneSet_Big_Comp_101411.txt";
//        String output = OVARIAN_DIR_NAME + "data_published_in_nature/SampleToRandomWalkGeneSet_Big_Comp_target_43_012412.txt";
//        String output = dirName + "SampleToRandomGeneSet_092112.txt";
//        String output = dirName + "SampleToRandomGeneSet_Big_Comp_092012.txt";
//        String output = dirName + "SampleToRandomWalkGeneSet_Big_Comp_092012.txt";
        String output = dirName + "SampleToRandomGeneSet_All_Genes_092012.txt";
        
        fu.setOutput(output);
        StringBuilder builder = new StringBuilder();
        builder.append("Sample");
        for (int i = 0; i < permutation; i++)
            builder.append("\t").append("random" + i);
        fu.printLine(builder.toString());
        builder.setLength(0);
        List<short[]> values = new ArrayList<short[]>();
        List<String> sampleList = new ArrayList<String>(sampleToGenes.keySet());
        System.out.println("Total genes used for randomization: " + geneSet.size());
        for (int i = 0; i < permutation; i++) {
            Set<String> randomSet = MathUtilities.randomSampling(geneSet, targetSize, randomizer);
//            Set<String> randomSet = randomWalkingOnFIs(geneToPartners, targetSize);
            short[] value = new short[sampleToGenes.size()];
            for (int j = 0; j < sampleList.size(); j++) {
                Set<String> genes = sampleToGenes.get(sampleList.get(j));
                if (InteractionUtilities.isShared(genes, randomSet))
                    value[j] = 1;
                else
                    value[j] = 0;
            }
            values.add(value);
        }
        // Output
        for (int i = 0; i < sampleList.size(); i++) {
            builder.append(sampleList.get(i));
            for (int j = 0; j < permutation; j++) {
                short[] value = values.get(j);
                builder.append("\t").append(value[i]);
            }
            fu.printLine(builder.toString());
            builder.setLength(0);
        }
        fu.close();
    }
    
    private Set<String> randomWalkingOnFIs(Map<String, Set<String>> geneToPartners,
                                           int targetSize) {
        Set<String> rtn = new HashSet<String>();
        List<String> list = new ArrayList<String>(geneToPartners.keySet());
        RandomData randomizer = new RandomDataImpl();
        int index = randomizer.nextInt(0, list.size() - 1);
        String current = list.get(index);
        rtn.add(current);
        while (rtn.size() < targetSize) {
            Set<String> partners = geneToPartners.get(current);
            list.clear();
            list.addAll(partners);
            if (list.size() == 1)
                index = 0;
            else
                index = randomizer.nextInt(0, list.size() - 1);
            current = list.get(index);
            rtn.add(current);
        }
        return rtn;
    }
    
    /**
     * Permutation tests
     * @throws Exception
     */
    @Test
    public void permutateNetworkModuleOverlapping() throws Exception {
        // For checking original sharing
        Set<String> fis = fu.loadInteractions(R3Constants.GENE_FI_BIG_COMP_FILE_NAME);
        Set<String> fiGenes = InteractionUtilities.grepIDsFromInteractions(fis);
        String fileName = OVARIAN_DIR_NAME + "ttest.genes.10.batch9_15.txt";
        List<String> batch9_15Genes = RUtilities.loadGeneList(fileName);
        System.out.println("Total batch9_15 genes: " + batch9_15Genes.size());
        batch9_15Genes.retainAll(fiGenes);
        System.out.println("in FIs: " + batch9_15Genes.size());
        fileName = OVARIAN_DIR_NAME + "ttest.genes.10.batch17_19.txt";
        List<String> batch17_19Genes = RUtilities.loadGeneList(fileName);
        System.out.println("Total batch17_19 genes: " + batch17_19Genes.size());
        batch17_19Genes.retainAll(fiGenes);
        System.out.println("in FIs: " + batch17_19Genes.size());
        
        // Starting permutation
        SpectralPartitionNetworkCluster clustering = new SpectralPartitionNetworkCluster();
        RandomData randomizer = new RandomDataImpl();
        List<Double> pvaluesList = new ArrayList<Double>();
        for (int k = 0; k < 100; k++) {
            System.out.println("Permutation " + k + "...");
            Set<String> set1 = MathUtilities.randomSampling(fiGenes,
                                                            batch9_15Genes.size(),
                                                            randomizer);
            Set<String> fis1 = InteractionUtilities.getFIs(set1, fis);
            List<Set<String>> clusters1 = clustering.cluster(fis1);
            Set<String> set2 = MathUtilities.randomSampling(fiGenes, 
                                                            batch17_19Genes.size(), 
                                                            randomizer);
            Set<String> fis2 = InteractionUtilities.getFIs(set2, fis);
            List<Set<String>> clusters2 = clustering.cluster(fis2);
            for (int i = 0; i < clusters1.size(); i++) {
                Set<String> module1 = clusters1.get(i);
                if (module1.size() < 10)
                    continue;
                for (int j = 0; j < clusters2.size(); j++) {
                    Set<String> module2 = clusters2.get(j);
                    if (module2.size() < 10)
                        continue;
                    Set<String> shared = InteractionUtilities.getShared(module1, module2);
                    Double pvalue = MathUtilities.calculateHypergeometricPValue(fiGenes.size(), 
                                                                                module1.size(), 
                                                                                module2.size(), 
                                                                                shared.size());
                    pvaluesList.add(pvalue);
                }
            }
        }
        Collections.sort(pvaluesList);
        fileName = OVARIAN_DIR_NAME + "NetworkOverlappingPermutationTest_040710.txt";
        fu.setOutput(fileName);
        for (int i = 0; i < pvaluesList.size(); i++)
            fu.printLine(i + "\t" + pvaluesList.get(i));
        fu.close();
    }
    
    /**
     * This method is used to check network overlapping between two modules.
     * @throws Exception
     */
    @Test
    public void checkModuleOverlappingsFromTwoClustersings() throws Exception {
        NetworkClusterAnalyzer clusterAnalyzer = new NetworkClusterAnalyzer();
        //String fileName = OVARIAN_DIR_NAME  + "ClustersForMutatedGenesSpectral_2Sample_040110.txt";
        String fileName = OVARIAN_DIR_NAME  + "ClustersForMutatedGenes_3Samples_051810.txt";
        List<Set<String>> modules1 = clusterAnalyzer.loadNetworkClusters(fileName);
        //fileName = OVARIAN_DIR_NAME + "ClustersForMutatedGenesEdge_2Sample_040210.txt";
        //fileName = OVARIAN_DIR_NAME  + "ClustersForMutatedGenes_3Samples_051810.txt";
        //fileName = OVARIAN_DIR_NAME + "ClustersForMutatedGenes_4Samples_051810.txt";
        fileName = OVARIAN_DIR_NAME + "ExomeMutationModules_3More_072610.txt";
        List<Set<String>> modules2 = clusterAnalyzer.loadNetworkClusters(fileName);
        for (int i = 0; i < modules2.size(); i++) {
            if (i == 1) {
                Set<String> module = modules2.get(i);
                System.out.println("Module " + i + ": " + module);
            }
        }
        // Get the total genes used
        Map<String, Set<String>> sampleToGenes = loadSampleToNonSynonymousMutatedGenes(false);
        filterSampleToGenes(sampleToGenes, 2);
        Set<String> allGenes = InteractionUtilities.grepAllGenes(sampleToGenes);
        clusterAnalyzer.checkNetworkModuleOverlapping(modules1, 
                                                      modules2, 
                                                      4, 
                                                      0.10d, 
                                                      allGenes);
    }
    
    /**
     * This method is used to check overlapping between two sets of network modules
     * @throws Exception
     */
    @Test
    public void networkModuleOverlappingAnalysis() throws Exception {
        NetworkClusterAnalyzer clusterAnalyzer = new NetworkClusterAnalyzer();
        String fileName = OVARIAN_DIR_NAME + "ClustersForTTestGenesBatch9_15.txt";
        List<Set<String>> batch9_15Modules = clusterAnalyzer.loadNetworkClusters(fileName);
        fileName = OVARIAN_DIR_NAME + "ClustersForTTestGenesBatch17_19.txt";
        //fileName = OVARIAN_DIR_NAME + "ClustersForMutatedGenesSpectral_2Sample_040110.txt";
        List<Set<String>> batch17_19Modules = clusterAnalyzer.loadNetworkClusters(fileName);
        Set<String> fis = fu.loadInteractions(R3Constants.GENE_FI_BIG_COMP_FILE_NAME);
        Set<String> fiGenes = InteractionUtilities.grepIDsFromInteractions(fis);
        // For checking original sharing
        fileName = OVARIAN_DIR_NAME + "ttest.genes.10.batch9_15.txt";
        List<String> batch9_15Genes = RUtilities.loadGeneList(fileName);
        //List<String> batch9_15Genes = new ArrayList<String>(clusterAnalyzer.grepAllGenesInClusters(batch9_15Modules));
        System.out.println("Total batch9_15 genes: " + batch9_15Genes.size());
        batch9_15Genes.retainAll(fiGenes);
        System.out.println("in FIs: " + batch9_15Genes.size());
        fileName = OVARIAN_DIR_NAME + "ttest.genes.10.batch17_19.txt";
        List<String> batch17_19Genes = RUtilities.loadGeneList(fileName);
        //List<String> batch17_19Genes = new ArrayList<String>(clusterAnalyzer.grepAllGenesInClusters(batch17_19Modules));
        System.out.println("Total batch17_19 genes: " + batch17_19Genes.size());
        batch17_19Genes.retainAll(fiGenes);
        System.out.println("in FIs: " + batch17_19Genes.size());
        Set<String> shared = InteractionUtilities.getShared(batch9_15Genes, batch17_19Genes);
        double pvalue = MathUtilities.calculateHypergeometricPValue(fiGenes.size(), 
                                                                    batch9_15Genes.size(),
                                                                    batch17_19Genes.size(), 
                                                                    shared.size());
        System.out.println("Total shared genes: " + shared.size()  + ", pvalue: " + pvalue);
        
        System.out.println("Batch9_15Module\tSize\tBatch17_19Module\tSize\tShared\tP-value");
        for (int i = 0; i < batch9_15Modules.size(); i++) {
            Set<String> module1 = batch9_15Modules.get(i);
            if (module1.size() < 10)
                continue;
            for (int j = 0; j < batch17_19Modules.size(); j++) {
                Set<String> module2 = batch17_19Modules.get(j);
                if (module2.size() < 10)
                    continue;
                shared = InteractionUtilities.getShared(module1, module2);
                pvalue = MathUtilities.calculateHypergeometricPValue(fiGenes.size(), 
                                                                            module1.size(), 
                                                                            module2.size(), 
                                                                            shared.size());
                System.out.println(i + "\t" + module1.size() + "\t" +
                                   j + "\t" + module2.size() + "\t" +
                                   shared.size() + "\t" + pvalue);
            }
        }
    }
    
    /**
     * This method is used to do network clustering from clin-related genes generated from R.
     * @throws Exception
     */
    @Test
    public void clusterClinRelatedGenes() throws Exception {
        String fileName = OVARIAN_DIR_NAME + "ttest.genes.10.batch17_19.txt";
        String clusterFileName = OVARIAN_DIR_NAME + "ClustersForTTestGenesBatch17_19.txt";
        List<String> geneList = RUtilities.loadGeneList(fileName);
        
        Set<String> fis = fu.loadInteractions(R3Constants.GENE_FI_BIG_COMP_FILE_NAME);
        Set<String> fiGenes = InteractionUtilities.grepIDsFromInteractions(fis);
        Set<String> geneInFIs = InteractionUtilities.getShared(fiGenes, geneList);
        Set<String> fisInGenes = InteractionUtilities.getFIs(geneList, fis);
        
        System.out.println("File: " + fileName);
        System.out.println("Total clin related genes: " + geneList.size());
        System.out.println("Genes in FIs: " + geneInFIs.size());
        System.out.println("FIs for clin genes: " + fisInGenes.size());
        
        SpectralPartitionNetworkCluster clustering = new SpectralPartitionNetworkCluster();
        long time1 = System.currentTimeMillis();
        List<Set<String>> clusters = clustering.cluster(fisInGenes);
        double modularity = clustering.calculateModualarity(clusters, fisInGenes);
        long time2 = System.currentTimeMillis();
        System.out.println("Time for clustering: " + (time2 - time1));
        System.out.println("Total clusters: " + clusters.size());
        System.out.println("Modularity: " + modularity);
//        new NetworkClusterAnalyzer().outputNetworkClusters(clusters, clusterFileName);
//        for (int i = 0; i < clusters.size(); i++) {
//            System.out.println("Module " + i + ": " + clusters.get(i).size());
//        }
    }
    
    /**
     * This method is used to group all significant genes together from individual
     * GSEA significant pathways.
     * @throws IOExecption
     */
    @Test
    public void groupGenesTogether() throws IOException {
        String fileName = OVARIAN_DIR_NAME + "gsea_up_genes.txt";
        final Map<String, Integer> geneToRank = new HashMap<String, Integer>();
        fu.setInput(fileName);
        String line = fu.readLine();
        line = fu.readLine();
        while ((line = fu.readLine()) != null) {
            line = line.trim();
            // Pathway line
            if (line.matches("(\\d)+. (.)+")) {
                System.out.println(line);
            }
            else if (line.length() == 0 || line.startsWith("??"))
                continue;
            else {
                String[] tokens = line.split("\t");
                geneToRank.put(tokens[0], new Integer(tokens[1]));
            }
        }
        fu.close();
        System.out.println("Total genes: " + geneToRank.size());
        // Order genes based on rank
        List<String> geneList = new ArrayList<String>(geneToRank.keySet());
        Collections.sort(geneList, new Comparator<String>() {
            public int compare(String gene1, String gene2) {
                Integer rank1 = geneToRank.get(gene1);
                Integer rank2 = geneToRank.get(gene2);
                return rank1.compareTo(rank2);
            }
        });
        for (String gene : geneList) {
            Integer rank = geneToRank.get(gene);
            System.out.println(gene + "\t" + rank);
        }
    }
    
    @Test
    public void checkBRCAMutations() throws Exception {
        Map<String, Set<String>> sampleToMutations = loadSampleToNonSynonymousMutatedGenes(false);
        Map<String, Set<String>> geneToSamples = InteractionUtilities.switchKeyValues(sampleToMutations);
        Set<String> brcaSamples = new HashSet<String>();
        for (String gene : geneToSamples.keySet()) {
            if (gene.equals("BRCA1") ||
                gene.equals("BRCA2")) {
                Set<String> samples = geneToSamples.get(gene);
                brcaSamples.addAll(samples);
                System.out.println(gene + ": " + samples.size());
            }
        }
        System.out.println("Total BRCA samples: " + brcaSamples.size());
        List<String> sampleList = new ArrayList<String>(brcaSamples);
        Collections.sort(sampleList);
        for (String sample : sampleList)
            System.out.println(sample);
    }
    
    @Test
    public void checkTOMClusters() throws Exception {
        String matrixFileName = "TOPForAlteredGenes011110.txt";
        String clusterFileName = "DClustersForTOPForAlteredGenes011110.txt";
        List<Set<String>> clusters = RUtilities.loadClustersFromDynamicTOM(OVARIAN_DIR_NAME + clusterFileName,
                                                                           OVARIAN_DIR_NAME + matrixFileName);
        int index = 1;
        for (Set<String> cluster : clusters) {
            System.out.println(index + ": " + cluster.size());
            System.out.println(cluster);
            index ++;
        }
        // Want to dump the clusters
        String outFileName = OVARIAN_DIR_NAME + "DClustersForTOPForAlteredGenes011110InGene.txt";
        fu.setOutput(outFileName);
        for (Set<String> cluster : clusters) {
            String line = cluster.toString();
            line = line.substring(1, line.length() - 1);
            line = line.replaceAll(", ", "\t");
            fu.printLine(line);
        }
        fu.close();
        Set<String> fis = fu.loadInteractions(R3Constants.GENE_FI_BIG_COMP_FILE_NAME);
        Set<String> fiGenes = InteractionUtilities.grepIDsFromInteractions(fis);
        // Checking sharing with MCL clusters
        List<Set<String>> mclClusters = new NetworkClusterAnalyzer().loadNetworkClusters(OVARIAN_DIR_NAME + "MCLForFIsInAlteredGenes112309.txt");
        System.out.println("TOMCluster\tMCLCluster\tShared\tP-value");
        int index1 = 0;
        for (Set<String> cluster : clusters) {
            int index2 = -1;
            for (Set<String> mclCluster : mclClusters) {
                index2 ++;
                Set<String> shared = InteractionUtilities.getShared(cluster, mclCluster);
                double pvalue = MathUtilities.calculateHypergeometricPValue(fiGenes.size(),
                                                                            cluster.size(), 
                                                                            mclCluster.size(), 
                                                                            shared.size());
                if (pvalue > 0.01)
                    continue;
                System.out.println(index1 + "\t" + index2 + "\t" + shared.size() + "\t" + pvalue);
            }
            index1 ++;
        }
    }
    
    @Test
    public void outputAlteredGenes() throws Exception {
        Set<String> mutatedGenes = loadOvarianMutatedGenes();
        System.out.println("#TCGA Ovarian Mutated Genes: " + mutatedGenes.size());
        for (String gene : mutatedGenes)
            System.out.println(gene);
    }
    
    /**
     * This process is very slow.
     * @throws Exception
     */
    @Test
    public void hiearchicalSamplesBasedOnGeneExp() throws Exception {
        Map<String, Set<String>> sampleToDiffGenes = loadSampleToDiffGenes(true);
        // Calculate scores between two samples based on gene overlapping
        int totalGene = 11833;
        List<String> sampleList = new ArrayList<String>(sampleToDiffGenes.keySet());
        Map<String, Double> samplePairToScore = new HashMap<String, Double>();
        for (int i = 0; i < sampleList.size() - 1; i++) {
            String sample1 = sampleList.get(i);
            Set<String> genes1 = sampleToDiffGenes.get(sample1);
            for (int j = i + 1; j < sampleList.size(); j++) {
                String sample2 = sampleList.get(j);
                Set<String> genes2 = sampleToDiffGenes.get(sample2);
                Set<String> shared = InteractionUtilities.getShared(genes1, genes2);
                double pvalue = MathUtilities.calculateHypergeometricPValue(totalGene, 
                                                                            genes1.size(),
                                                                            genes2.size(),
                                                                            shared.size());
                samplePairToScore.put(sample1 + "\t" + sample2,
                                      pvalue);
                System.out.println(sample1 + "\t" + sample2 + "\t" + pvalue);
            }
        }
        //hierchicallyClusterSamples(new ArrayList<String>(sampleToDiffGenes.keySet()),
        //                           sampleToDiffGenes);
    }
    
    @Test
    public void generateMinimumSpanForOvarianGenes() throws Exception {
        Set<String> genes = new HashSet<String>();
        String dirName = "datasets/TCGA/Ethan/";
        String fileName = dirName + "unified.txt";
        fu.setInput(fileName);
        String line = null;
        while ((line = fu.readLine()) != null) {
            System.out.println(line);
            if (line.startsWith("#"))
                continue;
            genes.add(line);
        }
        fu.close();
        System.out.println("Total genes: " + genes.size());
        // Check the gene coverage
//        Set<String> fis = fu.loadInteractions(R3Constants.GENE_FI_BIG_COMP_FILE_NAME);
        Set<String> fis = fu.loadInteractions(R3Constants.RESULT_DIR + "FIsInGene_Pathway_060109_BigComp.txt");
        Set<String> allGenes = InteractionUtilities.grepIDsFromInteractions(fis);
        Set<String> copy = new HashSet<String>(genes);
        copy.retainAll(allGenes);
        System.out.println("Genes in the FI network: " + copy.size());
        genes.retainAll(allGenes);
        String outFiFileName = dirName + "FIsInPathwayInUnified060109.txt";
        String nodeAttFileName = dirName + "FIsInPathwayInUnified060109.na";
        String outSpanFileName = dirName + "SpanInPathwayInUnified060109.txt";
        calculateMinimumSpan(outFiFileName,
                             outSpanFileName,
                             new ArrayList<String>(genes));
    }
    
    /**
     * There are two p53 pathways (actually three: another from B). This method is used to 
     * analyze similarities between these two pathways.
     * @throws Exception
     */
    @Test
    public void comparePathwaysFromDifferentSources() throws Exception {
        TopicAnalyzer topicAnalyzer = new TopicAnalyzer();
        Map<String, Set<String>> pathwayToGenes = topicAnalyzer.getTopicToNamesMap();
        List<String> pathways;
        System.out.println("Pathways:");
        printOutP53Pathways(pathwayToGenes);
        // Check two pathways
        compareTwoP53Pathways(pathwayToGenes);
        Map<String, Set<String>> pathwayClustersToGenes = topicAnalyzer.loadPathwayClusterToGenes();
        System.out.println("Pathway Clusters:");
        printOutP53Pathways(pathwayClustersToGenes);
        compareTwoP53Pathways(pathwayClustersToGenes);
    }
    
    private void compareTwoP53Pathways(Map<String, Set<String>> pathwayToGenes) throws IOException {
        Set<String> fis = fu.loadInteractions(R3Constants.GENE_FI_BIG_COMP_FILE_NAME);
        String pathway1 = "p53 pathway(P)";
        String pathway2 = "p53 signaling pathway(K)";
        System.out.println("Comparing \"" + pathway1 + "\" and \"" + pathway2 + "\":");
        Set<String> set1 = pathwayToGenes.get(pathway1);
        Set<String> set2 = pathwayToGenes.get(pathway2);
        // Check shared genes
        Set<String> shared = new HashSet<String>(set1);
        shared.retainAll(set2);
        // Find the smaller number
        int smaller = Math.min(set1.size(), set2.size());
        double per = (double) shared.size() / smaller;
        System.out.println("Shared proteins: " + per);
        // Get shared Fis
        Set<String> fis1 = InteractionUtilities.getFIs(set1, fis);
        Set<String> fis2 = InteractionUtilities.getFIs(set2, fis);
        shared = new HashSet<String>(fis1);
        shared.retainAll(fis2);
        smaller = Math.min(fis1.size(), fis2.size());
        per = (double) shared.size() / smaller;
        System.out.println("Shared FIs: " + per);
    }

    private void printOutP53Pathways(Map<String, Set<String>> pathwayToGenes) {
        List<String> pathways = new ArrayList<String>(pathwayToGenes.keySet());
        Collections.sort(pathways);
        for (String pathway : pathways) {
            Set<String> genes = pathwayToGenes.get(pathway);
            if (pathway.toLowerCase().startsWith("p53")) {
                System.out.println(pathway + "\t" + genes.size() + "\t" + genes);
            }
        }
    }
    
    /**
     * This method is used to generate a list of genes for the pathway clusters in GMT format using
     * our hierarchical clustering.
     * @throws Exception
     */
    @Test
    public void generatePathwayClusters() throws Exception {
        Map<String, Set<String>> pathwayToGenes = new TopicAnalyzer().getTopicToNamesMap();
        Set<String> fis = fu.loadInteractions(R3Constants.GENE_FI_BIG_COMP_FILE_NAME);
        Set<String> allGenes = InteractionUtilities.grepIDsFromInteractions(fis);
        BreadthFirstSearch bfs = new BreadthFirstSearch();
        Map<String, Set<String>> geneToPartners = bfs.generateIdToPartnersMap(fis);
        double cutoff = 2.0;
        String outFileName = R3Constants.RESULT_DIR + "Pathways_Reactome_28_plus_i_clusters_cutoff_2.gmt";
        fu.setOutput(outFileName);
        StringBuilder builder = new StringBuilder();
        int c = 0;
        for (String pathway : pathwayToGenes.keySet()) {
            System.out.println(c + ": " + pathway);
            c++;
            Set<String> genes = pathwayToGenes.get(pathway);
            // Need a little filters: this is strange actually. Why there are some genes have
            // not been linked?
            genes.retainAll(allGenes);
            Map<String, Integer> pairToDistance = calculateDistances(new ArrayList<String>(genes), 
                                                                     bfs, 
                                                                     geneToPartners);
            List<HierarchicalClusterNode> clusters = hierarchicalCluster(genes, 
                                                             pairToDistance,
                                                             false);
            HierarchicalClusterNode largestNode = searchLargestNode(clusters.get(0), cutoff);
            builder.append(pathway).append("\tna");
            for (String id : largestNode.getIds()) {
                builder.append("\t").append(id);
            }
            fu.printLine(builder.toString());
            builder.setLength(0);
        }
        fu.close();
    }
    
    /**
     * This method is used to search a pathway core with up or down regulated genes
     * @throws Exception
     */
    @Test
    public void checkPathwayCores() throws Exception {
        Map<String, Set<String>> pathwayToGenes = new TopicAnalyzer().getTopicToNamesMap();
        Set<String> fis = fu.loadInteractions(R3Constants.GENE_FI_BIG_COMP_FILE_NAME);
        Set<String> allGenes = InteractionUtilities.grepIDsFromInteractions(fis);
        BreadthFirstSearch bfs = new BreadthFirstSearch();
        Map<String, Set<String>> geneToPartners = bfs.generateIdToPartnersMap(fis);
        // Borrow this method to load genes
        Set<String> upGenes = fu.loadInteractions(OVARIAN_RESULT_DIR + "gene_exp_up_genes.txt");
        Set<String> downGenes = fu.loadInteractions(OVARIAN_RESULT_DIR + "gene_exp_down_genes.txt");
        System.out.println("Pathway\tPathway_Size\tUp_Cluser_Size\tDown_Cluster_Size\tUp_Cluster_Genes\tDown_Cluster_Genes");
        double cutoff = 0.75;
        for (String pathway : pathwayToGenes.keySet()) {
            Set<String> genes = pathwayToGenes.get(pathway);
            // Need a little filters: this is strange actually. Why there are some genes have
            // not been linked?
            genes.retainAll(allGenes);
            Map<String, Integer> pairToDistance = calculateDistances(new ArrayList<String>(genes), 
                                                                     bfs, 
                                                                     geneToPartners);
            List<HierarchicalClusterNode> clusters = hierarchicalCluster(genes, 
                                                             pairToDistance,
                                                             false);
            HierarchicalClusterNode biggestUpNode = searchLargestNode(clusters.get(0), 
                                                          upGenes,
                                                          cutoff);
            List<String> upClusterGenes = null;
            if (biggestUpNode == null)
                upClusterGenes = new ArrayList<String>();
            else {
                upClusterGenes = new ArrayList<String>(biggestUpNode.getIds());
                Collections.sort(upClusterGenes);
            }
            HierarchicalClusterNode biggestDownNode = searchLargestNode(clusters.get(0), 
                                                            downGenes,
                                                            cutoff);
            List<String> downClusterGenes = null;
            if (biggestDownNode == null)
                downClusterGenes = new ArrayList<String>();
            else {
                downClusterGenes = new ArrayList<String>(biggestDownNode.getIds());
                Collections.sort(downClusterGenes);
            }
            System.out.println(pathway + "\t" + 
                               genes.size() + "\t" + 
                               upClusterGenes.size() + "\t" + 
                               downClusterGenes.size() + "\t" +
                               upClusterGenes + "\t" + 
                               downClusterGenes);
        }
    }
    
    private HierarchicalClusterNode searchLargestNode(HierarchicalClusterNode root,
                                          Set<String> diffGenes,
                                          double cutoff) {
        List<HierarchicalClusterNode> goodNodes = new ArrayList<HierarchicalClusterNode>();
        searchGoodNodes(root, goodNodes, diffGenes, cutoff);
        // Find the largest nodes
        HierarchicalClusterNode rtn = null;
        for (HierarchicalClusterNode node : goodNodes) {
            if (rtn == null)
                rtn = node;
            else if (rtn.getIds().size() < node.getIds().size())
                rtn = node;
        }
        return rtn;
    }
    
    private void searchGoodNodes(HierarchicalClusterNode node,
                                 List<HierarchicalClusterNode> goodNodes,
                                 Set<String> diffGenes,
                                 double cutoff) {
        if (node == null)
            return;
        // Make sure all genes in the diff list
        int inDiffCount = 0;
        for (String id : node.getIds()) {
            if (diffGenes.contains(id)) {
                inDiffCount ++;
            }
        }
        double percent = inDiffCount / (double) node.getIds().size();
        if (percent >= cutoff)
            goodNodes.add(node);
        else {
            // Try its child nodes
            searchGoodNodes(node.getChildNode1(), goodNodes, diffGenes, cutoff);
            searchGoodNodes(node.getChildNode2(), goodNodes, diffGenes, cutoff);
        }
    }
    
    @Test
    public void checkOvarianLinkerGenes() throws Exception {
        Set<String> mutatedGenes = loadOvarianMutatedGenes();
        Set<String> clusterFIs = fu.loadInteractions(OVARIAN_RESULT_DIR + "FIsInClusterList051909.txt");
        Set<String> linkerGenes = InteractionUtilities.grepIDsFromInteractions(clusterFIs);
        linkerGenes.removeAll(mutatedGenes);
        System.out.println("Linker genes: " + linkerGenes.size());
        Map<String, String> geneNameToProteinName = new HibernateFIReader().loadShortNameToNameMap(linkerGenes);
        Map<String, Double> geneToTValue = new HashMap<String, Double>();
        Map<String, Double> geneToPValue = new HashMap<String, Double>();
        String fileName = OVARIAN_DIR_NAME + "GeneExp_t_value.txt";
        fu.setInput(fileName);
        String line = fu.readLine();
        while ((line = fu.readLine()) != null) {
            String[] tokens = line.split("\t");
            geneToTValue.put(tokens[0],
                             new Double(tokens[1])); 
            geneToPValue.put(tokens[0],
                             new Double(tokens[2]));
        }
        // Check if any changes in the CNV
        Map<String, List<String>> cnvAmplifiedGenes = getAmplifiedGeneToSamples();
        Map<String, List<String>> cnvDeletedGenes = getDeletedGeneToSamples();
        System.out.println("Gene\tCNV_Deletion_Samples\tCNV_Amplification_Samples\tt-score\tp-value\tProtein_Name");
        StringBuilder builder = new StringBuilder();
        int totalSamples = 151;
        for (String gene : linkerGenes) {
            builder.append(gene).append("\t");
            List<String> sampleWithDeletion = cnvDeletedGenes.get(gene);
            if (sampleWithDeletion != null) {
                builder.append(sampleWithDeletion.size());
                double ratio = (double) sampleWithDeletion.size() / totalSamples;
                builder.append("(").append(String.format("%.2f", ratio)).append(")");
            }
            builder.append("\t");
            List<String> sampleWithAmplifcation = cnvAmplifiedGenes.get(gene);
            if (sampleWithAmplifcation != null) {
                builder.append(sampleWithAmplifcation.size());
                double ratio = (double) sampleWithAmplifcation.size() / totalSamples;
                builder.append("(").append(String.format("%.2f", ratio)).append(")");
            }
            builder.append("\t");
            Double tscore = geneToTValue.get(gene);
            builder.append(String.format("%.2f", tscore)).append("\t");
            Double pvalue = geneToPValue.get(gene);
            builder.append(String.format("%.2e", pvalue)).append("\t");
            String proteinName = geneNameToProteinName.get(gene);
            builder.append(proteinName);
            System.out.println(builder.toString());
            builder.setLength(0);
        }
    }
    
    @Test
    public void processGeneExpTFileFromR() throws IOException {
        String fileName = OVARIAN_DIR_NAME + "GeneExp_t_value_R.txt";
        fu.setInput(fileName);
        String outFileName = OVARIAN_DIR_NAME + "GeneExp_t_value.txt";
        FileUtility outFu = new FileUtility();
        outFu.setOutput(outFileName);
        outFu.printLine("Gene\tt-score\tp-value");
        String line = null;
        int index = 0;
        while ((line = fu.readLine()) != null) {
            String[] tokens = line.split("\t");
            index = tokens[0].indexOf("|");
            String gene = tokens[0].substring(0, index);
            outFu.printLine(gene + "\t" + tokens[1] + "\t" + tokens[2]);
        }
        outFu.close();
        fu.close();
    }
    
    /**
     * This method is used to generate a normalized genes to mutations file. The normalization
     * is based on the total lengths of all exons from genes.
     * @throws Exception
     */
    @Test
    public void generateNormalizedGeneToMutationFile() throws Exception {
        fu.setInput(MUTATION_FILE);
        String line = fu.readLine();
        Map<String, Integer> geneToCount = new HashMap<String, Integer>();
        Set<String> allowedTypes = getAllowedMutationTypes();
        while ((line = fu.readLine()) != null) {
            //System.out.println(line);
            String[] tokens = line.split("\t");
            // If a sample is unknown, exclude this line
            if (tokens[15].equals("Unknown"))
                continue;
            if (!allowedTypes.contains(tokens[8].toLowerCase()))
                continue;
            Integer count = geneToCount.get(tokens[0]);
            String gene = tokens[0];
            if (count == null)
                geneToCount.put(gene, 1);
            else
                geneToCount.put(gene, ++count);
        }
        fu.close();
        System.out.println("Total genes: " + geneToCount.size());
        // Need to get length of exons
        final Map<String, Integer> geneToExonLength = new UCSCDataAnalyzer().loadGeneNameToAverageExonLength();
//        List<String> geneList = new ArrayList<String>(geneToExonLength.keySet());
//        Collections.sort(geneList, new Comparator<String>() {
//            public int compare(String gene1, String gene2) {
//                Integer l1 = geneToExonLength.get(gene1);
//                Integer l2 = geneToExonLength.get(gene2);
//                return l2 - l1;
//            }
//        });
//        for (int i = 0; i < 500; i++) {
//            String gene = geneList.get(i);
//            Integer length = geneToExonLength.get(gene);
//            System.out.println(gene + "\t" + length);
//        }
//        Integer length1 = geneToExonLength.get("TP53");
//        System.out.println("TP53: " + length1);
//        System.out.println("ZNF614: " + geneToExonLength.get("ZNF614"));
//        System.out.println("KCNJ12: " + geneToExonLength.get("KCNJ12"));
//        if (true)
//            return;
        Map<String, Double> geneToMutationScore = new HashMap<String, Double>();
        Map<String, Set<String>> sampleToGenes = loadSampleToNonSynonymousMutatedGenes(false);
        Map<String, Set<String>> geneToSamples = InteractionUtilities.switchKeyValues(sampleToGenes);
        Map<String, Integer> geneToSampleCount = new HashMap<String, Integer>();
        String output = OVARIAN_DIR_NAME + "ExomeGeneToMutation080610.txt";
        fu.setOutput(output);
        fu.printLine("Gene\tMutation\tNormalized\tSamples");
        List<String> notMapped = new ArrayList<String>();
        for (String gene : geneToCount.keySet()) {
            Integer mutation = geneToCount.get(gene);
            Integer length = geneToExonLength.get(gene);
            if (length == null) {
                //System.out.println(gene + " has no length!!!");
                notMapped.add(gene);
                continue;
//                throw new IllegalStateException(gene + " has no length!!!");
            }
            double score = (double) mutation / length;
            geneToMutationScore.put(gene, score);
            Set<String> samples = geneToSamples.get(gene);
            fu.printLine(gene + "\t" + 
                         mutation + "\t" + 
                         score + "\t" + 
                         samples.size());
            geneToSampleCount.put(gene, samples.size());
        }
        fu.close();
        // Generate Cytoscape attribute files
        InteractionUtilities.generateCytoscapeAttributeFile(geneToMutationScore,
                                                            "NormalizedMutationScore",
                                                            Double.class,
                                                            OVARIAN_DIR_NAME + "ExomeGeneNormMutationScore080610.txt");
        InteractionUtilities.generateCytoscapeAttributeFile(geneToSampleCount,
                                                            "SampleNumber",
                                                            Integer.class, 
                                                            OVARIAN_DIR_NAME + "ExomeGeneToSampleNumber080610.txt");
        System.out.println("Cannot mapped genes: " + notMapped.size());
        for (String gene : notMapped)
            System.out.println(gene);
    }
    
    @Test
    public void checkOVSamplesInMutationTable() throws Exception {
        fu.setInput(MUTATION_FILE);
        String line = fu.readLine();
        Map<String, Set<String>> centerToSamples = new HashMap<String, Set<String>>();
        Map<String, Set<String>> centerToGenes = new HashMap<String, Set<String>>();
        while ((line = fu.readLine()) != null) {
            String[] tokens = line.split("\t");
            String sample = tokens[15].substring(0, 12);
            InteractionUtilities.addElementToSet(centerToSamples, 
                                                 tokens[2],
                                                 sample);
            InteractionUtilities.addElementToSet(centerToGenes, 
                                                 tokens[2],
                                                 tokens[0]);
        }
        fu.close();
        int total = 0;
        System.out.println("Samples:");
        Set<String> totalSamples = new HashSet<String>();
        for (String center : centerToSamples.keySet()) {
            Set<String> samples = centerToSamples.get(center);
            System.out.println(center + "\t" + samples.size());
            total += samples.size();
            totalSamples.addAll(samples);
        }
        System.out.println("Total: " + total);
        System.out.println("Total samples: " + totalSamples.size());
        total = 0;
        System.out.println("\nGenes:");
        Set<String> totalGenes = new HashSet<String>();
        for (String center : centerToGenes.keySet()) {
            Set<String> genes = centerToGenes.get(center);
            System.out.println(center + "\t" + genes.size());
            total += genes.size();
            totalGenes.addAll(genes);
        }
        System.out.println("Total: " + total);
        System.out.println("Total genes: " + totalGenes.size());
        System.out.println("\nGenes sharing:");
        List<String> centers = new ArrayList<String>(centerToGenes.keySet());
        FisherExact fisher = new FisherExact(totalGenes.size());
        for (int i = 0; i < centers.size() - 1; i++) {
            String center1 = centers.get(i);
            Set<String> genes1 = centerToGenes.get(center1);
            for (int j = i + 1; j < centers.size(); j++) {
                String center2 = centers.get(j);
                Set<String> genes2 = centerToGenes.get(center2);
                Set<String> shared = InteractionUtilities.getShared(genes1, genes2);
//                double pvalue = MathUtilities.calculateHypergeometricPValue(totalGenes.size(),
//                                                                            genes1.size(),
//                                                                            genes2.size(),
//                                                                            shared.size());
                double pvalue = fisher.getP(shared.size(), 
                                            genes1.size() - shared.size(), 
                                            genes2.size() - shared.size(), 
                                            totalGenes.size() - genes1.size() - genes2.size() + shared.size());
                System.out.println(center1 + "\t" +
                                   center2 + "\t" +
                                   shared.size() + "\t" + 
                                   pvalue);
            }
        }
    }
    
    @Test
    public void checkMutationTable() throws IOException {
        boolean useHomo = false;
        // Need to call this method beyond the following statements related to fu.
        // Otherwise, the stream wrapped in fu will be closed.
        Set<String> validSamples = fu.loadInteractions(SEQUENCE_SAMPLE_FILE);
        System.out.println("Total sequenced samples: " + validSamples.size());
        //String fileName = OVARIAN_DIR_NAME + "Ovarian_phaseI_somatic_mutation_table.051309.txt";
        //String fileName = OVARIAN_DIR_NAME + "data_110609/mutation_summary_20091112.txt";
        fu.setInput(MUTATION_FILE);
        String line = fu.readLine();
        Set<String> mutatedGenes = new HashSet<String>();
        Set<String> nonsynonymousGenes = new HashSet<String>();
        Set<String> samples = new HashSet<String>();
        Set<String> mutationTypes = new HashSet<String>();
        Map<String, Integer> mutationStatus = new HashMap<String, Integer>();
        Map<String, Set<String>> geneToSamples = new HashMap<String, Set<String>>();
        Set<String> allowedStatus = new HashSet<String>();
        allowedStatus.add("LOH");
        allowedStatus.add("Somatic");
        allowedStatus.add("Germline");
        String[] arrays = new String[] {"Frame_Shift_Del", "In_Frame_Del", 
                "In_Frame_Ins", "Frame_Shift_Ins", "Nonsense_Mutation", 
                "Nonstop_Mutation", "Missense_Mutation", "Splice_Site_Ins", 
                "Splice_Site_SNP", "Splice_Site_Del"};
        Set<String> allowedTypes = new HashSet<String>(Arrays.asList(arrays));
        
        while ((line = fu.readLine()) != null) {
            //System.out.println(line);
            String[] tokens = line.split("\t");
            // If a sample is unknown, exclude this line
            if (tokens[15].equals("Unknown"))
                continue;
            //if (!allowedStatus.contains(tokens[25]))
            //    continue;
            mutatedGenes.add(tokens[0]);
            // Just want to get the code for sample
            //System.out.println("Sample: " + tokens[15]);
            String sample = tokens[15].substring(0, 12);
            if (!validSamples.contains(sample))
                continue;
            samples.add(sample);
            if (tokens[8].length() > 0)
                mutationTypes.add(tokens[8]);
            // Get mutation status
            Integer c = mutationStatus.get(tokens[25]);
            if (c == null) {
                mutationStatus.put(tokens[25], 1);
            }
            else {
                mutationStatus.put(tokens[25], ++c);
            }
//            if (!allowedTypes.contains(tokens[8]))
//                continue;
//            if (tokens[8].toLowerCase().equals("synonymous") ||
//                tokens[8].toLowerCase().equals("silent")) {
//                continue; // Don't want to count synonymous mutant
//            }
            if (tokens[8].toLowerCase().equals("rna") ||
                tokens[8].toLowerCase().equals("silent") ||
                  tokens[8].length() == 0) {
                continue; // Don't want to count synonymous mutant
            }
            if (useHomo) {
                String ref = tokens[10];
                String allel1 = tokens[11];
                String allel2 = tokens[12];
                if (ref.equals(allel1) ||
                    ref.equals(allel2))
                    continue;
            }
            nonsynonymousGenes.add(tokens[0]);
            InteractionUtilities.addElementToSet(geneToSamples, 
                                                 tokens[0],
                                                 sample);
        }
        fu.close();
        System.out.println("Total mutation types: " + mutationTypes.size() + " " + mutationTypes);
        System.out.println("Total mutated genes: " + mutatedGenes.size());
        System.out.println("Total non-synonymous mutated genes: " + nonsynonymousGenes.size());
        System.out.println("Total samples: " + samples.size());
        Map<String, Set<String>> sampleToGenes = InteractionUtilities.switchKeyValues(geneToSamples);
        // Check genes having two or more mutations
        Set<String> genesInTwoOrMoreSamples = new HashSet<String>();
        for (String gene : geneToSamples.keySet()) {
            samples = geneToSamples.get(gene);
            if (samples.size() > 1)
                genesInTwoOrMoreSamples.add(gene);
        }
        System.out.println("\nMutated genes in two or more samples: " + genesInTwoOrMoreSamples.size());
        // Check the coverage of FIs for these mutated genes
        Set<String> fis = fu.loadInteractions(R3Constants.GENE_FI_FILE_NAME);
        Set<String> fiGenes = InteractionUtilities.grepIDsFromInteractions(fis);
        
        // Check the coverage
        Set<String> shared = InteractionUtilities.getShared(fiGenes, mutatedGenes);
        double percentage = (double) shared.size() / mutatedGenes.size();
        System.out.println("Total mutated genes in FI: " + shared.size() + " (" + percentage + ")");
        shared = InteractionUtilities.getShared(fiGenes, nonsynonymousGenes);
        percentage = (double) shared.size() / nonsynonymousGenes.size();
        System.out.println("Total non-synonymous genes in FI: " + shared.size() + " (" + percentage + ")");
        shared = InteractionUtilities.getShared(fiGenes, genesInTwoOrMoreSamples);
        percentage = (double) shared.size() / genesInTwoOrMoreSamples.size();
        System.out.println("Mutated genes in two or more samples in FI: " + shared.size() + " (" + percentage + ")");
        
        // Print out samples to genes
        System.out.println("\nSample\tGenes\tGenesInTwoOrMoreSamples");
        for (String sample : sampleToGenes.keySet()) {
            Set<String> genes = sampleToGenes.get(sample);
            int allGenes = genes.size();
            genes.retainAll(genesInTwoOrMoreSamples);
            System.out.println(sample + "\t" + allGenes + "\t" + genes.size());
        }
        
        // Check the mutation status
        System.out.println("\nMutation status:");
        for (String status : mutationStatus.keySet()) {
            System.out.println(status + "\t" + mutationStatus.get(status));
        }
    }

    /**
     * In the mutation file, some samples are not correct. The lines for these samples should be filtered out.
     * @throws IOException
     */
    @Test
    public void filterMutationFile() throws IOException {
        FileUtility outFu = new FileUtility();
        // Generate a name for filtered file
        int index = MUTATION_FILE.lastIndexOf(".");
        String filteredFileName = MUTATION_FILE.substring(0, index) + "_filtered" + MUTATION_FILE.substring(index);
        outFu.setOutput(filteredFileName);
        Set<String> validatedSamples = fu.loadInteractions(SEQUENCE_SAMPLE_FILE);
        fu.setInput(MUTATION_FILE);
        String line = fu.readLine();
        outFu.printLine(line);
        while ((line = fu.readLine()) != null) {
            line = line.trim();
            if (line.length() == 0)
                continue;
            System.out.println(line);
            String[] tokens = line.split("\t");
            if (tokens[15].equals("Unknown"))
                continue;
            String sample = tokens[15].substring(0, 12);
            if (validatedSamples.contains(sample)) {
                outFu.printLine(line);
            }
        }
        fu.close();
        outFu.close();
    }
    
    @Test
    public void compareMutatedGenesInGenomicAndExomeDatasets() throws Exception {
        Map<String, Set<String>> sampleToGenes = loadSampleToNonSynonymousMutatedGenes(false);
        System.out.println("Total samples: " + sampleToGenes.size());
        Set<String> totalGenes = InteractionUtilities.grepAllGenes(sampleToGenes);
        System.out.println("Total mutated genes: " + totalGenes.size());
        // Load genomic mutated table
        MUTATION_FILE = OVARIAN_DIR_NAME  + "data_031910/mutations/TCGA_OV_Capture_Exchange_Consolidated_wustl_bcm_broad.wustl_annotation.11mar2010u.maf_filtered.txt";
        SEQUENCE_SAMPLE_FILE = OVARIAN_DIR_NAME + "data_031910/SampleList/sequenced_3_16_2010.txt";
        Map<String, Set<String>> genomicSampleToGenes = loadSampleToNonSynonymousMutatedGenes(false);
        System.out.println("Total samples: " + genomicSampleToGenes.size());
        Set<String> gTotalGenes = InteractionUtilities.grepAllGenes(genomicSampleToGenes);
        System.out.println("Total genomic mutated genes: " + gTotalGenes.size());
        Set<String> shared = InteractionUtilities.getShared(totalGenes, gTotalGenes);
        System.out.println("Shared genes: " + shared.size());
        // Pick genes in three or more samples
        filterSampleToGenes(sampleToGenes, 3);
        filterSampleToGenes(genomicSampleToGenes, 3);
        System.out.println("\nMutated genes in three or more samples:");
        totalGenes = InteractionUtilities.grepAllGenes(sampleToGenes);
        gTotalGenes = InteractionUtilities.grepAllGenes(genomicSampleToGenes);
        System.out.println("Total exome genes: " + totalGenes.size());
        System.out.println("Total genomic genes: " + gTotalGenes.size());
        shared = InteractionUtilities.getShared(totalGenes, gTotalGenes);
        System.out.println("Shared genes: " + shared.size());
        // The following is used to check Network module sharing
        NetworkClusterAnalyzer clusterAnalyzer = new NetworkClusterAnalyzer();
        String fileName = OVARIAN_DIR_NAME  + "ClustersForMutatedGenes_3Samples_051810.txt";
        List<Set<String>> gModules = clusterAnalyzer.loadNetworkClusters(fileName);
        fileName = OVARIAN_DIR_NAME + "ExomeMutationModules_3More_072610.txt";
        List<Set<String>> eModules = clusterAnalyzer.loadNetworkClusters(fileName);
        // Need to do a filter
        for (Set<String> module : gModules)
            module.retainAll(shared);
        for (Set<String> module : eModules)
            module.retainAll(shared);
        System.out.println("\nNetwork module overlapping analysis (based on 3 or more samples):");
        clusterAnalyzer.checkNetworkModuleOverlapping(eModules, 
                                                      gModules, 
                                                      1, 
                                                      0.10d, 
                                                      shared);
    }
    
    /**
     * This method is used to load the map from sample to mutated genes. Only non-synonymous genes
     * have been listed.
     * @return
     * @throws IOException
     */
    protected Map<String, Set<String>> loadSampleToNonSynonymousMutatedGenes(boolean useHomo) throws IOException {
        return new MATFileLoader().loadSampleToGenes(MUTATION_FILE, useHomo);
//        Set<String> allowedStatus = new HashSet<String>();
//        allowedStatus.add("LOH");
//        allowedStatus.add("Somatic");
//        allowedStatus.add("Germline");
//        Set<String> allowedTypes = getAllowedMutationTypes();
//
//        Map<String, Set<String>> sampleToGenes = new HashMap<String, Set<String>>();
//        fu.setInput(MUTATION_FILE);
//        String line = fu.readLine();
//        while ((line = fu.readLine()) != null) {
//            //System.out.println(line);
//            String[] tokens = line.split("\t");
//            // If a sample is unknown, exclude this line
//            if (tokens[15].equals("Unknown"))
//                continue;
//            if (!allowedTypes.contains(tokens[8]))
//                continue;
//            // For exonome mutation file
////            if (tokens[8].equals("Silent") ||
////                tokens[8].equals("RNA") ||
////                tokens[8].length() == 0)
////                continue;
////            if (!allowedStatus.contains(tokens[25]))
////                continue;
////            if (tokens[8].toLowerCase().equals("synonymous") ||
////                tokens[8].toLowerCase().equals("silent")) {
////                continue; // Don't want to count synonymous mutant
////            }
//            if (useHomo) {
//                String ref = tokens[10];
//                String allel1 = tokens[11];
//                String allel2 = tokens[12];
//                if (ref.equals(allel1) ||
//                    ref.equals(allel2))
//                    continue;
//            }
//            // Just want to get the code for sample
//            String sample = tokens[15].substring(0, 12);
//            InteractionUtilities.addElementToSet(sampleToGenes, 
//                                                 sample,
//                                                 tokens[0]);
//        }
//        fu.close();
//        // Do a filtering for valid samples only
//        Set<String> validSamples = fu.loadInteractions(SEQUENCE_SAMPLE_FILE);
//        Set<String> notSequenced = new HashSet<String>(sampleToGenes.keySet());
//        notSequenced.removeAll(validSamples);
//        System.out.println("Not sequenced: " + notSequenced.size() + ": " + notSequenced);
//        sampleToGenes.keySet().retainAll(validSamples);
//        System.out.println("Total samples from mutations: " + sampleToGenes.size());
//        return sampleToGenes;
    }

    private Set<String> getAllowedMutationTypes() {
        return new MATFileLoader().getAllowedMutationTypes();
//        String[] arrays = new String[] {"Frame_Shift_Del", "In_Frame_Del", 
//                "In_Frame_Ins", "Frame_Shift_Ins", "Nonsense_Mutation", 
//                "Nonstop_Mutation", "Missense_Mutation", "Splice_Site_Ins", 
//                "Splice_Site_SNP", "Splice_site_SNP", "Splice_Site_Del", "StopCodon_DNP", 
//                "Splice_Site", "Stop_Codon_Del", "Init_Met_Del"};
//        return new HashSet<String>(Arrays.asList(arrays));
    }
    
    @Test
    public void checkMutatedGenesInSamples() throws IOException {
        Map<String, Set<String>> sampleToGenes = loadSampleToNonSynonymousMutatedGenes(true);
        final Map<String, Set<String>> geneToSamples = InteractionUtilities.switchKeyValues(sampleToGenes);
        List<String> geneList = new ArrayList<String>(geneToSamples.keySet());
        Collections.sort(geneList, new Comparator<String>() {
            public int compare(String gene1, String gene2) {
                Set<String> samples1 = geneToSamples.get(gene1);
                Set<String> samples2 = geneToSamples.get(gene2);
                return samples2.size() - samples1.size();
            }
        });
        System.out.println("Gene\tSamples");
        for (String gene : geneList) {
            Set<String> samples = geneToSamples.get(gene);
            System.out.println(gene + "\t" + samples.size());
        }
        System.out.println();
        Set<String> genes = new HashSet<String>();
        System.out.println("Sample\tGenes");
        for (int i = 1; i < 21; i++) {
            genes.clear();
            for (String gene : geneToSamples.keySet()) {
                Set<String> samples = geneToSamples.get(gene);
                if (samples.size() >= i) 
                    genes.add(gene);
            }
            System.out.println(i + "\t" + genes.size());
        }
        System.out.println("\n" + genes);
    }
    
    private Set<String> loadMutatedGenesInSamples(boolean useHomo,
                                                  int sampleNumber) throws IOException {
        Map<String, Set<String>> sampleToGenes = loadSampleToNonSynonymousMutatedGenes(useHomo);
        System.out.println("Total samples: " + sampleToGenes.size());
        Map<String, Set<String>> geneToSamples = InteractionUtilities.switchKeyValues(sampleToGenes);
        Set<String> rtn = new HashSet<String>();
        for (String gene : geneToSamples.keySet()) {
            Set<String> samples = geneToSamples.get(gene);
            if (samples.size() >= sampleNumber)
                rtn.add(gene);
        }
        return rtn;
    }
    
    /**
     * This method is used to annotate mutated genes occurring in two or more samples.
     * @throws IOException
     */
    @Test
    public void annotateMutatedGenes() throws Exception {
        Set<String> genes = loadMutatedGenesInSamples(false, 10);
        System.out.println("Total genes: " + genes.size());
        // Use ranked genes for permutation: which is more liked used for mutations checking
        Map<String, Double> geneToScore = loadGeneRankers();
        System.out.println("Total genes in ranker: " + geneToScore.size());
        PathwayBasedAnnotator annotator = new PathwayBasedAnnotator();
        annotator.setRandomGenes(new HashSet<String>(geneToScore.keySet()));
        //annotator.setPValueThreshold(0.001);
        annotator.setFDRThreshold(0.50);
//        FileOutputStream fos = new FileOutputStream(new File("test.txt"));
//        PrintStream ps = new PrintStream(fos);
//        annotator.setPrintStream(ps);
        annotator.annotateGenesWithFDR(genes, AnnotationType.Pathway);
    }
    
    @Test
    public void testLoadMutatedGenes() throws Exception {
        Set<String> genes = loadMutatedGenesInSamples(false, 3);
        System.out.println("Total genes: " + genes.size());
        Set<String> fis = fu.loadInteractions(R3Constants.GENE_FI_FILE_NAME);
        Set<String> genesInFIs = InteractionUtilities.grepIDsFromInteractions(fis);
        genes.retainAll(genesInFIs);
        System.out.println("In FI Network: " + genes.size());
        Set<String> fisInGenes = InteractionUtilities.getFIs(genes, fis);
        System.out.println("Total FIs in genes: " + fisInGenes.size());
        Set<String> linkedGenes = InteractionUtilities.grepIDsFromInteractions(fisInGenes);
        System.out.println("Total linked genes: " + linkedGenes.size());
        
//        Map<String, Set<String>> sampleToGenes = new MATFileLoader().loadSampleToGenes(MUTATION_FILE, false);
//        genes = CancerAnalysisUtilitites.selectGenesInSamples(3, sampleToGenes);
//        System.out.println("\n\nGenes for Plug-in: " + genes.size());
//        genes.retainAll(genesInFIs);
//        System.out.println("In FI Network: " + genes.size());
//        fisInGenes = InteractionUtilities.getFIs(genes, fis); 
//        System.out.println("Total FIs in genes: " + fisInGenes.size());
//        linkedGenes = InteractionUtilities.grepIDsFromInteractions(fisInGenes);
//        System.out.println("Linked genes: " + linkedGenes.size());
    }
    
    /**
     * This method is used to analyze mutated genes occurring in two or more samples using a network
     * module-based method.
     * @throws Exception
     */
    @Test
    public void networkModuleAnalysisOfMutatedGenes() throws Exception {
        //Set<String> genes = loadMutatedGenesInSamples(false, 4);
        // Try to use homo mutated genes
        Set<String> genes = loadMutatedGenesInSamples(true, 1);
        System.out.println("Total mutated genes: " + genes.size());
        NetworkClusterAnalyzer clusterAnalyzer = new NetworkClusterAnalyzer();
        //List<Set<String>> clusters = clusterAnalyzer.cluster(genes);
        // use this fixed ratio to decrease the time 
        //List<Set<String>> clusters = clusterAnalyzer.cluster(genes, 0.11);
        String fileName = OVARIAN_DIR_NAME + "NetworkModulesForHomoMutatedGenes112009.txt";
        //clusterAnalyzer.outputNetworkClusters(clusters, fileName);
        List<Set<String>> clusters = clusterAnalyzer.loadNetworkClusters(fileName);
        Set<String> fis = fu.loadInteractions(R3Constants.GENE_FI_BIG_COMP_FILE_NAME);
        Set<String> fiInGenes = InteractionUtilities.getFIs(genes, fis);
        double modularity = clusterAnalyzer.calculateModularity(clusters, fiInGenes);
        System.out.println("Modularity: " + modularity);
        int index = 0;
        for (Set<String> cluster : clusters) {
            System.out.println(index + ": " + cluster.size());
            index ++;
        }
        // Annotate clusters
        clusterAnalyzer.annotateNetworkClusters(clusters, 5);
    }
    
    @Test
    public void networkModuleAnalysisOfAlteredGenes() throws Exception {
        Map<String, Set<String>> sampleToAlteredGenes = loadSampleToAlteredGenes();
        Map<String, Set<String>> alteredGenesToSamples = InteractionUtilities.switchKeyValues(sampleToAlteredGenes);
        Set<String> genes = new HashSet<String>(alteredGenesToSamples.keySet());
        System.out.println("Total altered genes used: " + genes.size());
        NetworkClusterAnalyzer clusterAnalyzer = new NetworkClusterAnalyzer();
        //List<Set<String>> clusters = clusterAnalyzer.cluster(genes);
        // use this fixed ratio to decrease the time 
        //List<Set<String>> clusters = clusterAnalyzer.cluster(genes, 0.02);
        //String fileName = OVARIAN_DIR_NAME + "NetworkModulesForAlteredGenes112309.txt";
        String fileName = OVARIAN_DIR_NAME + "MCLForFIsInAlteredGenes112309.txt";
        //clusterAnalyzer.outputNetworkClusters(clusters, fileName);
        List<Set<String>> clusters = clusterAnalyzer.loadNetworkClusters(fileName);
        Set<String> fis = fu.loadInteractions(R3Constants.GENE_FI_BIG_COMP_FILE_NAME);
        Set<String> fiInGenes = InteractionUtilities.getFIs(genes, fis);
        double modularity = clusterAnalyzer.calculateModularity(clusters, fiInGenes);
        System.out.println("Modularity: " + modularity);
        int index = 0;
        for (Set<String> cluster : clusters) {
            System.out.println(index + ": " + cluster.size());
            index ++;
        }
        // Annotate clusters
        clusterAnalyzer.annotateNetworkClusters(clusters, 10);
    }
    
    /**
     * This method is used to generate the matrix from samples to network modules. The
     * values in the matrix are based on connection degrees in the network modules.
     * @throws Exception
     */
    @Test
    public void generateSampleToNetworkModuleMatrixInDegrees() throws Exception {
        //String clusterFileName = OVARIAN_DIR_NAME + "NetworkModulesForAlteredGenes112309.txt";
        //Map<String, Set<String>> sampleToGenes = loadSampleToNonSynonymousMutatedGenes(true);
        //String clusterFileName = OVARIAN_DIR_NAME + "MCLForFIsInAlteredGenes112309.txt";
        String clusterFileName = OVARIAN_DIR_NAME + "ClustersForMutatedGenesSpectral_2Sample_040110.txt";
        Map<String, Set<String>> sampleToGenes = loadSampleToNonSynonymousMutatedGenes(false);
        NetworkClusterAnalyzer clusterAnalyzer = new NetworkClusterAnalyzer();
        //String outFileName = OVARIAN_DIR_NAME + "SampleToMCLNetworkModulesForAlteredGenesInDegreesNorm113009.txt";
        String outFileName = OVARIAN_DIR_NAME + "SamplesToClustersForMutatedGenesSpectral_2Sample_InDegreesNorm_11_042010.txt";
        clusterAnalyzer.generateSampleToModulesMatrixInDegrees(sampleToGenes, 
                                                               clusterFileName, 
                                                               outFileName,
                                                               11);
    }
    
    /**
     * This method is used to generate a matrix from samples to pathways based on connection
     * degrees in pathways using FIs.
     * @throws Exception
     */
    @Test
    public void generateSampleToPathwayMatrixInDegrees() throws Exception {
        //Map<String, Set<String>> sampleToGenes = loadSampleToAlteredGenes();
        Map<String, Set<String>> sampleToGenes = loadSampleToNonSynonymousMutatedGenes(true);
        NetworkClusterAnalyzer clusterAnalyzer = new NetworkClusterAnalyzer();
        String outFileName = OVARIAN_DIR_NAME + "SampleToPathwaysForHomoMutatedGenesInDegreesNormIndPathwayFIs120409.txt";
        clusterAnalyzer.generateSampleToPathwayMatrixInDegrees(sampleToGenes, 
                                                               outFileName,
                                                               null,
                                                               10);        
    }
    
    /**
     * Try to find hit pathways.
     * @throws Exception
     */
    @Test
    public void pathwayHitAnalysisBasedOnSamples() throws Exception {
        Map<String, Set<String>> sampleToGenes = loadSampleToNonSynonymousMutatedGenes(false);
        System.out.println("Total samples: " + sampleToGenes.size());
        Set<String> allGenes = new HashSet<String>();
        for (Set<String> genes : sampleToGenes.values())
            allGenes.addAll(genes);
        System.out.println("Total genes: " + allGenes.size());
        PathwayBasedAnnotator annotator = new PathwayBasedAnnotator();
        //annotator.annotateGenesWithFDR(allGenes);
//        annotator.annotatePathwayBasedOnSamples(sampleToGenes,
//                                                false,
//                                                false);
    }
    
    @Test
    public void generateGeneToSampleNumbers() throws IOException {
        Map<String, Set<String>> sampleToGenes = loadSampleToNonSynonymousMutatedGenes(false);
        //filterSampleToGenes(sampleToGenes, 2);
        Map<String, Set<String>> geneToSamples = InteractionUtilities.switchKeyValues(sampleToGenes);
        System.out.println("Gene\tSample_Number\tSamples");
        for (String gene : geneToSamples.keySet()) {
            Set<String> samples = geneToSamples.get(gene);
            System.out.println(gene + "\t" + 
                               samples.size() + "\t" + 
                               InteractionUtilities.joinStringElements(";", samples));
        }
    }
    
    /**
     * This method is used to list mutated genes in a set of pathways. The genes will be sorted based
     * on the numbers of samples having gene mutated.
     * @throws Exception
     */
    @Test
    public void sortMutatedGenesInHitPathwayBasedOnSamples() throws Exception {
        Map<String, Set<String>> sampleToGenes = loadSampleToNonSynonymousMutatedGenes(false);
        final Map<String, Set<String>> geneToSamples = InteractionUtilities.switchKeyValues(sampleToGenes);
        System.out.println("Total samples: " + sampleToGenes.size());
        Set<String> mutatedGenes = new HashSet<String>();
        for (Set<String> set : sampleToGenes.values())
            mutatedGenes.addAll(set);
        System.out.println("Total mutated genes: " + mutatedGenes.size());
        TopicAnalyzer topicAnalyzer = new TopicAnalyzer();
        Map<String, Set<String>> pathwayToGenes = topicAnalyzer.getTopicToNamesMap();
        String fileName = OVARIAN_DIR_NAME + "ImpactedPathwaysByMutationsFromSamples.txt";
        List<String> pathways = new ArrayList<String>();
        fu.setInput(fileName);
        String line = fu.readLine();
        while ((line = fu.readLine()) != null) {
            String[] tokens = line.split("\t");
            pathways.add(tokens[0]);
        }
        fu.close();
        System.out.println("Total pathways: " + pathways.size());
        // Get the mutated genes in the hit pathways
        Set<String> mutatedGenesInPathways = new HashSet<String>();
        int index = 1;
        for (String pathway : pathways) {
            Set<String> pathwayGenes = pathwayToGenes.get(pathway);
            Set<String> mutatedPathwayGenes = InteractionUtilities.getShared(pathwayGenes, mutatedGenes);
            mutatedGenesInPathways.addAll(mutatedPathwayGenes);
            // Print mutated genes in pathways: genes should have occur in at least 2 samples
            List<String> list = new ArrayList<String>(mutatedPathwayGenes);
            Collections.sort(list, new Comparator<String>() {
                public int compare(String gene1, String gene2) {
                    Set<String> samples1 = geneToSamples.get(gene1);
                    Set<String> samples2 = geneToSamples.get(gene2);
                    return samples2.size() - samples1.size();
                }
            });
            System.out.println("\n" + index + ": " + pathway);
            for (String gene : list) {
                Set<String> samples = geneToSamples.get(gene);
                if (samples.size() >= 2)
                    System.out.println(gene + "\t" + samples.size());
            }
            index ++;
        }
        System.out.println("Total mutated genes in hit pathways: " + mutatedGenesInPathways.size());
        // Need to sort genes based on sample numbers
        List<String> list = new ArrayList<String>(mutatedGenesInPathways);
        Collections.sort(list, new Comparator<String>() {
            public int compare(String gene1, String gene2) {
                Set<String> samples1 = geneToSamples.get(gene1);
                Set<String> samples2 = geneToSamples.get(gene2);
                return samples2.size() - samples1.size();
            }
        });
        for (String gene : list) {
            Set<String> samples = geneToSamples.get(gene);
            if (samples.size() >= 2)
                System.out.println(gene + "\t" + samples.size());
        }
    }
    
    @Test
    public void generateSampleToNetworkModuleMatrix() throws Exception {
        //String clusterFileName = OVARIAN_DIR_NAME + "NetworkModulesForAlteredGenes112309.txt";
        //Map<String, Set<String>> sampleToGenes = loadSampleToNonSynonymousMutatedGenes(true);
        //String clusterFileName = OVARIAN_DIR_NAME + "MCLForFIsInAlteredGenes112309.txt";
        //String clusterFileName = OVARIAN_DIR_NAME + "DClustersForTOPForAlteredGenes011110InGene.txt";
        //String clusterFileName = OVARIAN_DIR_NAME + "ClustersForMutatedGenesEdge_2Sample_040210.txt";
        //String clusterFileName = OVARIAN_DIR_NAME + "ClustersForMutatedGenesSpectral_2Sample_040110.txt";
        //String clusterFileName = OVARIAN_DIR_NAME + "ClustersForMutatedGenes_4Samples_051810.txt";
        //String clusterFileName = OVARIAN_DIR_NAME + "ClustersForAlteredGenes_2Samples_060110.txt";
//        String clusterFileName = OVARIAN_DIR_NAME + "ExomeMutationModules_4More_072710.txt";
//        String clusterFileName = OVARIAN_DIR_NAME + "ExomeMutationModules_4More_091310.txt";
        //String outFileName = OVARIAN_DIR_NAME + "SampleToMCLNetworkModulesForAlteredGenes112309.txt";
        //String outFileName = OVARIAN_DIR_NAME + "SampleToTOMNetworkModulesForAlteredGenes011110.txt";
        //String outFileName = OVARIAN_DIR_NAME  + "SamplesToClustersForMutatedGenesEdge_2Sample_10_042010.txt";
        //String outFileName = OVARIAN_DIR_NAME  + "SamplesToClustersForMutatedGenesSpectral_2Sample_4_051210.txt";
        //String outFileName = OVARIAN_DIR_NAME  + "SamplesToClustersForMutatedGenesSpectral_4Samples_4_051810.txt";
        //String outFileName = OVARIAN_DIR_NAME  + "SamplesToClustersForAlteredGenes_2Samples_4_060110.txt";
//        String outFileName = OVARIAN_DIR_NAME + "SamplesToExomeMutationModules_4More_091310.txt";
        
//        String clusterFileName = OVARIAN_DIR_NAME + "FireHose/2012FISubNetwork_Sample3_No_SigGenes_Modules_092012.txt";
//        String outFileName = OVARIAN_DIR_NAME + "FireHose/SampleTo2012FISubNetwork_Sample3_No_SigGenes_Modules_092012.txt";
        
//        String clusterFileName = OVARIAN_DIR_NAME + "FireHose/2012FISubNetwork_Sample3_Modules_092012.txt";
//        String outFileName = OVARIAN_DIR_NAME + "FireHose/SampleTo2012FISubNetwork_Sample3_Modules_092012.txt";
        
//        String clusterFileName = OVARIAN_DIR_NAME + "FireHose/2012FISubNetwork_Sample3_No_UBC_Modules_092012.txt";
//        String outFileName = OVARIAN_DIR_NAME + "FireHose/SampleTo2012FISubNetwork_Sample3_No_UBC_Modules_092012.txt";
        
//        String clusterFileName = OVARIAN_DIR_NAME + "FireHose/2009FISubNetwork_Sample3_Modules_092012.txt";
//        String outFileName = OVARIAN_DIR_NAME + "FireHose/SampleTo2009FISubNetwork_Sample3_Modules_092012.txt";
        
//        String clusterFileName = OVARIAN_DIR_NAME + "FireHose/2012FISubNetwork_Sample4_No_SigGenes_Modules_092012.txt";
//        String outFileName = OVARIAN_DIR_NAME + "FireHose/SampleTo2012FISubNetwork_Sample4_No_SigGenes_Modules_092012.txt";
        
        String dirName = "datasets/TCGA/GBM/FireHose/";
        String clusterFileName = dirName + "2012FISubNetwork_Sample5_Modules_092012.txt";
        String outFileName = dirName + "SampleTo2012FISubNetwork_Sample5_Modules_092012.txt";
        
        //Map<String, Set<String>> sampleToGenes = loadSampleToAlteredGenes();
        String mutationFileName = dirName + "FH_GBM.Mutation_Significance.Level_4.20120725/GBM.final_analysis_set.maf";
        Map<String, Set<String>> sampleToGenes = new MATFileLoader().loadSampleToGenes(mutationFileName, false);
        //Map<String, Set<String>> sampleToGenes = loadSampleToNonSynonymousMutatedGenes(false);
        NetworkClusterAnalyzer clusterAnalyzer = new NetworkClusterAnalyzer();
        clusterAnalyzer.generateSampleToModulesMatrix(sampleToGenes, 
                                                      clusterFileName, 
                                                      outFileName,
                                                      0);
    }
    
    /**
     * This method is used to generate a sample to altered genes matrix. The altered genese
     * is provided by some pre-selection criteria.
     * @throws Exception
     */
    @Test
    public void generateSampleToAlteredGenesMatrix() throws Exception {
        //Map<String, Set<String>> sampleToGenes = loadSampleToAlteredGenes();
        Map<String, Set<String>> sampleToGenes = loadSampleToNonSynonymousMutatedGenes(false);
        //String geneFile = OVARIAN_DIR_NAME + "PlatSignificantAlteredGenesPValue_025.txt";
        //Set<String> selectedGenes = fu.loadInteractions(geneFile);
        //Map<String, Set<String>> geneToSamples = InteractionUtilities.switchKeyValues(sampleToGenes);
        //Set<String> selectedGenes = new HashSet<String>(geneToSamples.keySet());
        Set<String> selectedGenes = new HashSet<String>();
        selectedGenes.add("BRCA1");
        selectedGenes.add("BRCA2");
        System.out.println("Total selected genes: " + selectedGenes.size());
        //String outFileName = OVARIAN_DIR_NAME + "SampleToAlteredGenes122109_homo_mut_All.txt";
        String outFileName = OVARIAN_DIR_NAME + "SampleToBRCAMutations091310.txt";
        NetworkClusterAnalyzer clusterAnalyzer = new NetworkClusterAnalyzer();
        clusterAnalyzer.generateSampleToSelectedGenesMatrix(sampleToGenes,
                                                            selectedGenes,
                                                            outFileName);
    }
    
    /**
     * This method is used to generate sample to gene mutation and expression scores. This method is
     * similar to another method generateSampleToGeneSetExpScore(), except that the gene set is provided
     * explicitly in method.
     * @throws Exception
     */
    @Test
    public void generateSampleToGeneSetExpScoreAndMutations() throws Exception {
//        String line = "GRIN3A,GRIN2B,GRIN2D,GRIN2A,RASGRF2,RYR3,RYR1,RYR2,CACNA2D1," +
//        		      "CACNA1S,CACNA1G,CACNA1E,CACNA1F,CACNA1C,CACNA1D,CACNA1A,GRIA4,AKAP6";
//        String line = "DYNC2H1,DYNC1H1,DYNC1I1,DNAH11,DNAH10,DNAH9,DNAH3,DNAH1,DNAH2,DNAH7,DNAH8,DNAH5";
//        String line = "MAP3K7,DYNC2H1,DYNC1H1,ACVR2B,KALRN,DNAH11,DNAH10," +
//        		"DNAH9,DNAH3,BMPR2,DNAH1,DNAH2,DNAH7,DNAH8,DNAH5,TGFBR2";
//        String line = "CEP250,CEP290,DYNC1H1,PPP2R1A,DCTN1,TUBA4A,AKAP9,CEP192,PCNT,ALMS1,CENPJ";
        //String line = "GRIN2D,GRIN2A,RYR3,RYR1,RYR2,CACNA1S,CACNA1G,CACNA1E,CACNA1F,CACNA1C,CACNA1D,CACNA1A";
        //String line = "GRIN3A,GRIN2B,GRIN2D,DYNC2H1,DYNC1H1,DYNC1I1,GRIN2A,DCTN1," +
        //		"KALRN,DNAH11,DNAH10,DNAH9,DNAH3,DNAH1,DNAH7,DNAH8,DNAH5,HAP1,HTT,CYFIP2,CYFIP1";
        String line = "DYNC2H1,DYNC1H1,DYNC1I1,DCTN1,TUBA4A,DNAH11,DNAH10,DNAH9,DNAH3,DNAH1," +
        		"DNAH2,DNAH7,DNAH8,DNAH5,TUBA3C,CENPJ,CEP250,CEP290,DYNC1H1,PPP2R1A,DCTN1," +
        		"TUBA4A,AKAP9,CEP192,PCNT,ALMS1,CENPJ";
        String[] geneSet = line.split(",");
        Set<String> genes = new HashSet<String>();
        for (String gene : geneSet)
            genes.add(gene);
        System.out.println("Total genes: " + genes.size());
        Map<String, Map<String, Double>> geneToSampleToValue = loadGeneExp();
        // Do some clean up of the above file
        for (String gene : geneToSampleToValue.keySet()) {
            Map<String, Double> sampleToValue = geneToSampleToValue.get(gene);
            Map<String, Double> copy = new HashMap<String, Double>();
            for (String sample : sampleToValue.keySet()) {
                if (sample.contains(".11A."))
                    continue; // Don't want to use normal samples
                Double value = sampleToValue.get(sample);
                sample = sample.substring(0, 12);
                sample = sample.replaceAll("\\.", "-");
                copy.put(sample, value);
            }
            geneToSampleToValue.put(gene, copy);
        }
        // Reference gene expression patterns are based on average values for all cancer samples
        List<Double> meanValues = new ArrayList<Double>();
        Map<String, List<Double>> sampleToValues = new HashMap<String, List<Double>>();
        for (String gene : genes) {
            Map<String, Double> sampleToValue = geneToSampleToValue.get(gene);
            if (sampleToValue == null)
                continue;
            // Calculate average
            double total = 0.0d;
            for (String sample : sampleToValue.keySet()) {
                Double value = sampleToValue.get(sample);
                total += value;
                List<Double> values = sampleToValues.get(sample);
                if (values == null) {
                    values = new ArrayList<Double>();
                    sampleToValues.put(sample, values);
                }
                values.add(value);
            }
            meanValues.add(total / sampleToValue.size());
        }
        System.out.println("Total samples in sampleToValues: " + sampleToValues.size());
        String outFileName = OVARIAN_DIR_NAME + "SampleToExpMeanForModule4_Microtube_G2M_Module_100410.txt";
        fu.setOutput(outFileName);
        fu.printLine("Sample\tType\tAverage\tCorrelation");
        double cutoff = 0.0d;
        for (String sample : sampleToValues.keySet()) {
            List<Double> values = sampleToValues.get(sample);
            Double corr = MathUtilities.calculatePearsonCorrelation(meanValues, values);
            Double average = MathUtilities.calculateMean(values);
            if (average > cutoff)
                fu.printLine(sample + "\t1\t" + average + "\t" + corr);
            else if (average < -cutoff)
                fu.printLine(sample + "\t-1\t" + average + "\t" + corr);
        }
    }
    
    /**
     * This method is used to generate a file containing sample to t-score from gene expression
     * data file based on a set of genes. The method is based on paper by Creighton et al 2008. 
     * Journal of Oncology 26: 4078.
     * @throws Exception
     */
    @Test
    public void generateSampleToGeneSetExpScore() throws Exception {
        // Need to load gene sets
        String clusterFileName = OVARIAN_DIR_NAME + "ExomeMutationModules_3More_091310.txt";
        NetworkClusterAnalyzer clusterAnalyzer = new NetworkClusterAnalyzer();
        List<Set<String>> modules = clusterAnalyzer.loadNetworkClusters(clusterFileName);
        // Get want to get the fifth module
        Set<String> module = modules.get(4);
        System.out.println("Genes in module: " + module.size() + ": " + module);
//        // Loading these mutated genes to filter out samples having mutated genes
//        Map<String, Set<String>> sampleToMutatedGenes = loadSampleToNonSynonymousMutatedGenes(false);
//        Set<String> sequencedSamples = new HashSet<String>(sampleToMutatedGenes.keySet());
//        Set<String> totalGenes = InteractionUtilities.grepAllGenes(sampleToMutatedGenes);
//        filterSampleToGenes(sampleToMutatedGenes, 3);
//        System.out.println("Before filtering: " + sampleToMutatedGenes.size() + " with total genes " + totalGenes.size());
//        for (Iterator<String> it = sampleToMutatedGenes.keySet().iterator(); it.hasNext();) {
//            String sample = it.next();
//            Set<String> genes = sampleToMutatedGenes.get(sample);
//            genes.retainAll(module);
//            if (genes.size() == 0)
//                it.remove();
//        }
//        totalGenes = InteractionUtilities.grepAllGenes(sampleToMutatedGenes);
//        System.out.println("After filtering: " + sampleToMutatedGenes.size() + " with total genes " + totalGenes.size());
        // Load genes
        Map<String, Map<String, Double>> geneToSampleToValue = loadGeneExp();
        // Do some clean up of the above file
        for (String gene : geneToSampleToValue.keySet()) {
            Map<String, Double> sampleToValue = geneToSampleToValue.get(gene);
            Map<String, Double> copy = new HashMap<String, Double>();
            for (String sample : sampleToValue.keySet()) {
                if (sample.contains(".11A."))
                    continue; // Don't want to use normal samples
                Double value = sampleToValue.get(sample);
                sample = sample.substring(0, 12);
                sample = sample.replaceAll("\\.", "-");
                copy.put(sample, value);
            }
            geneToSampleToValue.put(gene, copy);
        }
        // Reference gene expression patterns are based on average values for all cancer samples
        List<Double> meanValues = new ArrayList<Double>();
        Map<String, List<Double>> sampleToValues = new HashMap<String, List<Double>>();
        for (String gene : module) {
            Map<String, Double> sampleToValue = geneToSampleToValue.get(gene);
            if (sampleToValue == null)
                continue;
            // Calculate average
            double total = 0.0d;
            for (String sample : sampleToValue.keySet()) {
                Double value = sampleToValue.get(sample);
                total += value;
                List<Double> values = sampleToValues.get(sample);
                if (values == null) {
                    values = new ArrayList<Double>();
                    sampleToValues.put(sample, values);
                }
                values.add(value);
            }
            meanValues.add(total / sampleToValue.size());
        }
        System.out.println("Total samples in sampleToValues: " + sampleToValues.size());
        System.out.println("Sample\tType\tAverage\tCorrelation");
        double cutoff = 0.15d;
        for (String sample : sampleToValues.keySet()) {
//            // We just want to check samples having no mutated genes in three or more samples
//            if (sampleToMutatedGenes.keySet().contains(sample))
//                continue;
//            if (!sequencedSamples.contains(sample))
//                continue;
            List<Double> values = sampleToValues.get(sample);
            Double corr = MathUtilities.calculatePearsonCorrelation(meanValues, values);
            Double average = MathUtilities.calculateMean(values);
            if (average > cutoff)
                System.out.println(sample + "\t1\t" + average + "\t" + corr);
            else if (average < -cutoff)
                System.out.println(sample + "\t-1\t" + average + "\t" + corr);
//            if (corr >= 0.30) {
//                System.out.println(sample + "\t1");
//            }
//            else if (corr <= -0.30) {
//                System.out.println(sample + "\t-1");
//            }
        }
    }
    
    
    /**
     * This method is used to generate a sample to mutated gene file.
     * @throws Exception
     */
    @Test
    public void generateSampleToMutatedGenesInClusterFile() throws Exception {
        //String clusterFileName = OVARIAN_DIR_NAME + "ClustersForMutatedGenesSpectral_2Sample_040110.txt";
        String clusterFileName = OVARIAN_DIR_NAME  + "ExomeMutationModules_3More_072610.txt";
        NetworkClusterAnalyzer analyzer = new NetworkClusterAnalyzer();
        List<Set<String>> clusters = analyzer.loadNetworkClusters(clusterFileName);
        Map<String, Set<String>> sampleToAlteredGenes = loadSampleToNonSynonymousMutatedGenes(false);
        filterSampleToGenes(sampleToAlteredGenes, 3);
        int[] selectedClusters = new int[] {0, 4, 5, 10};
        Set<String> selectedGenes = new HashSet<String>();
        for (int cluster : selectedClusters) {
            selectedGenes.addAll(clusters.get(cluster));
        }
        System.out.println("Size of selected genes: " + selectedGenes.size());
//        String outFileName = OVARIAN_DIR_NAME + "SampleToGenesInModule2_050310.txt";
        String outFileName = OVARIAN_DIR_NAME  + "SampleToGenesInExomeMutationModules_3More_072610.txt";
        analyzer.generateSampleToSelectedGenesMatrix(sampleToAlteredGenes, 
                                                     selectedGenes,
                                                     outFileName);
    }
    
    @Test
    public void generateSampleToNetworkModuleMatrixInPValue() throws Exception {
        String clusterFileName = OVARIAN_DIR_NAME + "NetworkModulesForMutatedGenesInThreeOrMore111609.txt";
        Map<String, Set<String>> sampleToGenes = loadSampleToNonSynonymousMutatedGenes(false);
        // Need to do a filter based on sample occurence
        Set<String> genesIn3OrMore = loadMutatedGenesInSamples(false, 3);
        System.out.println("Total genes in three or more smples: " + genesIn3OrMore.size());
        // Want to focus on FI genes only
        Set<String> fis = fu.loadInteractions(R3Constants.GENE_FI_BIG_COMP_FILE_NAME);
        Set<String> fiGenes = InteractionUtilities.grepIDsFromInteractions(fis);
        genesIn3OrMore.retainAll(fiGenes);
        System.out.println("in fi network: " + genesIn3OrMore.size());
        // filter genes in samples
        for (String sample : sampleToGenes.keySet()) {
            Set<String> genes = sampleToGenes.get(sample);
            genes.retainAll(genesIn3OrMore);
        }
        NetworkClusterAnalyzer clusterAnalyzer = new NetworkClusterAnalyzer();
        String outFileName = OVARIAN_DIR_NAME + "SampleToModulesForMutatedGenesInThreeOrMoreInPValue111909_size_5.txt";
        clusterAnalyzer.generateSampleToModulesMatrixInPValue(sampleToGenes, 
                                                              clusterFileName, 
                                                              outFileName,
                                                              5,
                                                              genesIn3OrMore.size());
    }
    
    /**
     * This method is used to compare clustering overlapping.
     * @throws Exception
     */
    @Test
    public void compareTwoSampleClusters() throws Exception {
        // Load clusters from network modules
        String clusterFileName = OVARIAN_DIR_NAME + "SampleClustersForSamplesToClustersForMutatedGenesSpectral_2Sample_040110.txt";
        //String clusterFileName = OVARIAN_DIR_NAME + "SampleClustersForSamplesToClustersForMutatedGenesEdge_2Sample_10_042010.txt";
        List<List<String>> clusters = RUtilities.loadHierarchicalClustersFromR(clusterFileName);
        Set<String> allSamples = new HashSet<String>();
        int index = 0;
        for (List<String> cluster : clusters) {
            System.out.println(index + "\t" + cluster.size());
            index ++;
            allSamples.addAll(cluster);
        }
        System.out.println("Total samples: " + allSamples.size());
        // Load samples from gene expression generated by others
        String fileName = OVARIAN_DIR_NAME + "data_031910/TCGA_232_UE_top1500.k3.txt";
        fu.setInput(fileName);
        String line = fu.readLine();
        List<Set<String>> expClusters = new ArrayList<Set<String>>();
        for (int i = 0; i < 3; i++) {
            expClusters.add(new HashSet<String>());
        }
        while ((line = fu.readLine()) != null) {
            String[] tokens = line.split("\t");
            int cluster = Integer.parseInt(tokens[1]);
            Set<String> set = expClusters.get(cluster - 1);
            set.add(tokens[0].substring(0, 12));
        }
        fu.close();
        Set<String> allExpSamples = new HashSet<String>(); 
        index = 0;
        for (Set<String> cluster : expClusters) {
            System.out.println(index + "\t" + cluster.size());
            index ++;
            allExpSamples.addAll(cluster);
        }
        System.out.println("Total example samples: " + allExpSamples.size());
        // Need to do a filtering
        allExpSamples.retainAll(allSamples);
        // Make sure all mutated samples are in exp samples
        System.out.println("Exp samples in mutated samples: " + allExpSamples.size());
        // Do a filtering
        allSamples.retainAll(allExpSamples);
        for (List<String> cluster : clusters)
            cluster.retainAll(allSamples);
        for (Set<String> cluster : expClusters)
            cluster.retainAll(allSamples);
        // Do a pari-wise hypergeometric test
        System.out.println("\nClusterFromMutation\tClusterFromGeneExp\tShared\tp-value");
        for (int i = 0; i < clusters.size(); i++) {
            List<String> cluster = clusters.get(i);
            for (int j = 0; j < expClusters.size(); j++) {
                Set<String> expCluster = expClusters.get(j);
                Set<String> shared = InteractionUtilities.getShared(cluster, expCluster);
                double pvalue = MathUtilities.calculateHypergeometricPValue(allSamples.size(),
                                                                            cluster.size(),
                                                                            expCluster.size(),
                                                                            shared.size());
                System.out.println(i + "\t" + j + "\t" +
                                   shared.size() + "\t" + pvalue);
            }
        }
    }
    
    /**
     * This method is used to check some properties from hierarchical clustering using R.
     * @throws Exception
     */
    @Test
    public void checkSampleClustersFromRhclust() throws Exception {
        // Total samples have been used for clustering
        String fileName = OVARIAN_DIR_NAME + "SamplesInOrderForSamplesToClustersForMutatedGenesSpectral_2Sample_040110.txt";
        List<String> clusteredSamples = RUtilities.loadSamplesInRHClust(fileName);
        System.out.println("Total samples used for hclust: " + clusteredSamples.size());
        String clusterFileName = OVARIAN_DIR_NAME + "SampleClustersForSamplesToClustersForMutatedGenesSpectral_2Sample_040110.txt";
        System.out.println("Cluster file name: " + clusterFileName);
        //HierarchicalCluster clusterAnalyzer = new HierarchicalCluster();
        List<List<String>> clusters = RUtilities.loadHierarchicalClustersFromR(clusterFileName);
        TCGAOvarianCancerClinicalAnalyzer clinicalAnalyzer = new TCGAOvarianCancerClinicalAnalyzer();
        Map<String, Double> sampleToPlatInterval = clinicalAnalyzer.loadSampleToPlatinumFreeInterval(false);
        int index = 1;
        for (List<String> cluster : clusters) {
            System.out.println("Cluster " + index + ": " + cluster.size()); // + ", " + cluster);
//            if (index == 2) {
//                for (String sample : cluster) {
//                    Double in = sampleToPlatInterval.get(sample);
//                    System.out.println(sample + "\t" + in);
//                }
//            }
            index ++;
        }
        System.out.println("\nCheck platinum free interval:");
        // Check sample platinum information
        System.out.println("Total samples with meaningful platinum-free-interval: " + sampleToPlatInterval.size());
        sampleToPlatInterval.keySet().retainAll(clusteredSamples);
        System.out.println("in clusters: " + sampleToPlatInterval.size());
        List<String> senSamples = new ArrayList<String>();
        List<String> resSamples = new ArrayList<String>();
        for (String sample : sampleToPlatInterval.keySet()) {
            Double interval = sampleToPlatInterval.get(sample);
//            if (interval > 7.30) // Median value
//                senSamples.add(sample);
//            else 
//                resSamples.add(sample); 
            if (interval >= 9)
                senSamples.add(sample);
            else if (interval <= 6)
            //else
                resSamples.add(sample);
        }
        System.out.println("Total sensitive samples: " + senSamples.size());
        System.out.println("Total resistant samples: " + resSamples.size());
        // Need to make sure both groups have the same clusters
        index = 1;
        for (List<String> cluster : clusters) {
            // Need to copy so that cluster can be used by the following method.
            cluster = new ArrayList<String>(cluster);
            cluster.retainAll(sampleToPlatInterval.keySet());
            System.out.println("Cluster " + index + ": " + cluster.size());
            // Check sen
            Set<String> shared = InteractionUtilities.getShared(cluster, senSamples);
            double pvalue = MathUtilities.calculateHypergeometricPValue(sampleToPlatInterval.size(),
                                                                        cluster.size(),
                                                                        senSamples.size(),
                                                                        shared.size());
            System.out.println("\tsen: " + shared.size() + "\t" + pvalue);
            // Check res
            shared = InteractionUtilities.getShared(cluster, resSamples);
            pvalue = MathUtilities.calculateHypergeometricPValue(sampleToPlatInterval.size(),
                                                                 cluster.size(),
                                                                 resSamples.size(),
                                                                 shared.size());
            System.out.println("\tres: " + shared.size() + "\t" + pvalue);
            index ++;
        }
        System.out.println("\nCheck for primary therapy outcome:");
        // Check primary output
        Map<String, String> sampleToPrimaryOutcome = clinicalAnalyzer.loadSampleToPrimaryTherapyOutcome();
        System.out.println("Total samples with primary outcome information: " + sampleToPrimaryOutcome.size());
        sampleToPrimaryOutcome.keySet().retainAll(clusteredSamples);
        System.out.println("in clustered samples: " + sampleToPrimaryOutcome.size());
        Map<String, Set<String>> primaryOutcomeToSamples = new HashMap<String, Set<String>>();
        for (String sample : sampleToPrimaryOutcome.keySet()) {
            String outcome = sampleToPrimaryOutcome.get(sample);
            InteractionUtilities.addElementToSet(primaryOutcomeToSamples,
                                                 outcome,
                                                 sample);
        }
        // Just a quick check
        for (String output : primaryOutcomeToSamples.keySet()) {
            Set<String> samples = primaryOutcomeToSamples.get(output);
            System.out.println(output + ": " + samples.size());
        }
        index = 1;
        for (List<String> cluster : clusters) {
            cluster = new ArrayList<String>(cluster);
            cluster.retainAll(sampleToPrimaryOutcome.keySet());
            System.out.println("Cluster " + index + ": " + cluster.size());
            for (String outcome : primaryOutcomeToSamples.keySet()) {
                Set<String> outcomeSamples = primaryOutcomeToSamples.get(outcome);
                Set<String> shared = InteractionUtilities.getShared(outcomeSamples, cluster);
                double pvalue =  MathUtilities.calculateHypergeometricPValue(sampleToPrimaryOutcome.size(), 
                                                                             cluster.size(), 
                                                                             outcomeSamples.size(), 
                                                                             shared.size());
                System.out.println(outcome + "\t" + shared.size() + "\t" + pvalue);
            }
            index ++;
        }
    }
    
    @Test
    public void drawDiagramForSampleClinInfoForhclustFromR() throws IOException {
        //String fileName = OVARIAN_DIR_NAME + "SamplesInOrderFor20GenesFromrbsurv.txt";
        String fileName = OVARIAN_DIR_NAME + "SamplesInOrderForSamplesToClustersForMutatedGenesSpectral_2Sample_040110.txt";
        List<String> samples = RUtilities.loadSamplesInRHClust(fileName);
        System.out.println("Total samples in order: " + samples.size());
        // Check sample platinum information
        TCGAOvarianCancerClinicalAnalyzer clinicalAnalyzer = new TCGAOvarianCancerClinicalAnalyzer();
        Map<String, Double> sampleToPlatInterval = clinicalAnalyzer.loadSampleToPlatinumFreeInterval(true);
        Map<String, String> sampleToPlat = new HashMap<String, String>();
        List<String> platTypes = new ArrayList<String>();
        platTypes.add("sen");
        platTypes.add("int");
        platTypes.add("res");
        int resCount = 0;
        int senCount = 0;
        int intCount = 0;
        for (String sample : sampleToPlatInterval.keySet()) {
            Double interval = sampleToPlatInterval.get(sample);
            if (interval <= 6) {
                sampleToPlat.put(sample, "res");
                resCount ++;
            }
            else if (interval >= 9) {
                sampleToPlat.put(sample, "sen");
                senCount ++;
            }
            else {
                sampleToPlat.put(sample, "int");
                intCount ++;
            }
        }
        // Just a quick check
        for (String sample : samples) {
            String type = sampleToPlat.get(sample);
            System.out.println(sample + "\t" + type);
        }
        System.out.printf("Samples in different plat types:%n\tres: %d, sen: %d, int: %d%n",
                          resCount,
                          senCount,
                          intCount);
        List<Color> platColors = new ArrayList<Color>();
        platColors.add(Color.red);
        platColors.add(Color.yellow);
        platColors.add(Color.green);
        fileName = OVARIAN_DIR_NAME + "SamplesInOrderForSamplesToClustersForMutatedGenesSpectral_2Sample_040110Plat.png";
        HierarchicalCluster cluster = new HierarchicalCluster();
        cluster.drawSampleInformation(sampleToPlat, 
                                      samples,
                                      platTypes, 
                                      platColors, 
                                      1200, 
                                      50,
                                      fileName);
        // Check primary output
        Map<String, String> sampleToPrimaryOutcome = clinicalAnalyzer.loadSampleToPrimaryTherapyOutcome();
        Set<String> outcomes = new HashSet<String>(sampleToPrimaryOutcome.values());
        List<String> infoList = new ArrayList<String>(outcomes);
        for (String outcome : infoList)
            System.out.println(outcome);
        List<Color> colorList = new ArrayList<Color>();
        colorList.add(Color.red);
        colorList.add(Color.green);
        colorList.add(Color.blue);
        colorList.add(Color.cyan);
        fileName = OVARIAN_DIR_NAME + "SamplesInOrderForSamplesToClustersForMutatedGenesSpectral_2Sample_040110PrimaryOutput.png";
        
        cluster.drawSampleInformation(sampleToPrimaryOutcome, 
                                      samples,
                                      infoList, 
                                      colorList, 
                                      1200, 
                                      50,
                                      fileName);
    }
    
    /**
     * This method is used to generate an FI file for mutated genes.
     * @throws Exception
     */
    @Test
    public void generateFIFileForMutatedGenes() throws Exception {
        //Set<String> genes = loadMutatedGenesInSamples(false, 4);
        //Set<String> genes = loadMutatedGenesInSamples(true, 1);
        //System.out.println("Total mutated genes: " + genes.size());
        // String outFileName = OVARIAN_DIR_NAME + "FIsInHomoMutatedGenes112309.txt";
        //Map<String, Set<String>> sampleToAlteredGenes = loadSampleToAlteredGenes();
        Map<String, Set<String>> sampleToAlteredGenes = loadSampleToNonSynonymousMutatedGenes(false);
        filterSampleToGenes(sampleToAlteredGenes, 2);
        Map<String, Set<String>> alteredGenesToSamples = InteractionUtilities.switchKeyValues(sampleToAlteredGenes);
        Set<String> genes = new HashSet<String>(alteredGenesToSamples.keySet());
        System.out.println("Total altered genes: " + genes.size());
        //String outFileName = OVARIAN_DIR_NAME + "FIsInAlteredGenes112309.txt";
        String outFileName = OVARIAN_DIR_NAME + "FIsInMutatedGenes_Sample_2_032210.txt";
        Set<String> fis = fu.loadInteractions(R3Constants.GENE_FI_BIG_COMP_FILE_NAME);
        Set<String> fisInMutated = InteractionUtilities.getFIs(genes, fis);
        System.out.println("Total FIs: " + fisInMutated.size());
        fu.saveInteractions(fisInMutated, outFileName);
//        // Try to generate gene to sample attribute file
//        Map<String, Set<String>> sampleToGenes = loadSampleToNonSynonymousMutatedGenes(true);
//        Map<String, Set<String>> geneToSamples = InteractionUtilities.switchKeyValues(sampleToGenes);
//        String attFileName = OVARIAN_DIR_NAME + "HomoMutatedGeneToSamples112309.na";
//        fu.setOutput(attFileName);
//        fu.printLine("MutatedSamples (class=java.lang.Integer)");
//        for (String gene : geneToSamples.keySet()) {
//            Set<String> samples = geneToSamples.get(gene);
//            fu.printLine(gene + "=" + samples.size());
//        }
//        fu.close();
    }
    
    @Test
    public void checkCNVGenes() throws IOException {
        Map<String, List<String>> deletedGeneToSamples = getDeletedGeneToSamples();
        Map<String, List<String>> amplifiedGeneToSamples = getAmplifiedGeneToSamples();
        Set<String> totalGenes = new HashSet<String>();
        totalGenes.addAll(deletedGeneToSamples.keySet());
        totalGenes.addAll(amplifiedGeneToSamples.keySet());
        System.out.println("Total CNV genes: " + totalGenes.size());
        // Check the FI network
        Set<String> fis = fu.loadInteractions(R3Constants.GENE_FI_FILE_NAME);
        Set<String> fiGenes = InteractionUtilities.grepIDsFromInteractions(fis);
        totalGenes.retainAll(fiGenes);
        System.out.println("Total CNV genes in FI network: " + totalGenes.size());
        Map<String, Set<String>> sampleToCNVGenes = loadSampleToCNVGenes();
    }
        
    public Map<String, Set<String>> loadSampleToCNVGenes() throws IOException {
        Map<String, List<String>> deletedGeneToSamples = getDeletedGeneToSamples();
        Map<String, List<String>> amplifiedGeneToSamples = getAmplifiedGeneToSamples();
        System.out.println("Originally loaded:");
        System.out.println("Total CNV deleted genes: " + deletedGeneToSamples.keySet().size());
        System.out.println("Total CNV amplified genes: " + amplifiedGeneToSamples.keySet().size());
        // Want to keep genes in ranked only: these genes are more likely cancer related
//        Map<String, Double> geneToRanker = loadGeneRankers();
//        System.out.println("Total genes in gene ranker: " + geneToRanker.keySet().size());
//        for (Iterator<String> it = deletedGeneToSamples.keySet().iterator(); it.hasNext();) {
//            String gene = it.next();
//            if (!geneToRanker.keySet().contains(gene))
//                it.remove();
//        }
//        for (Iterator<String> it = amplifiedGeneToSamples.keySet().iterator(); it.hasNext();) {
//            String gene = it.next();
//            if (!geneToRanker.keySet().contains(gene))
//                it.remove();
//        }
//        System.out.println("Using gene ranker list:");
//        System.out.println("Total CNV deleted genes: " + deletedGeneToSamples.keySet().size());
//        System.out.println("Total CNV amplifed genes: " + amplifiedGeneToSamples.keySet().size());
        // There are 151 samples in total. Want to use genes occurring at least in 10% (15 samples).
        int sampleNumberCutoff = 12;
        for (Iterator<String> it = deletedGeneToSamples.keySet().iterator(); it.hasNext();) {
            String gene = it.next();
            List<String> samples = deletedGeneToSamples.get(gene);
            if (samples.size() < sampleNumberCutoff)
                it.remove();
        }
        //sampleNumberCutoff = 2;
        for (Iterator<String> it = amplifiedGeneToSamples.keySet().iterator(); it.hasNext();) {
            String gene = it.next();
            List<String> samples = amplifiedGeneToSamples.get(gene);
            if (samples.size() < sampleNumberCutoff)
                it.remove();
        }
        System.out.println("Using samples cutoff: " + sampleNumberCutoff);
        System.out.println("Total CNV deleted genes: " + deletedGeneToSamples.keySet().size());
        System.out.println("Total CNV amplified genes: " + amplifiedGeneToSamples.keySet().size());
        // Don't want to get genes sometime deleted and some time amplified: these genes
        // should be regarded as false positive
        Set<String> sharedGenes = new HashSet<String>(deletedGeneToSamples.keySet());
        sharedGenes.retainAll(amplifiedGeneToSamples.keySet());
        System.out.println("Total shared genes in deletion and amplification: " + sharedGenes.size());
        Map<String, Set<String>> sampleToGenes = new HashMap<String, Set<String>>();
        deletedGeneToSamples.putAll(amplifiedGeneToSamples);
        for (String gene : deletedGeneToSamples.keySet()) {
            if (sharedGenes.contains(gene))
                continue;
            List<String> samples = deletedGeneToSamples.get(gene);
            for (String sample : samples) {
                Set<String> geneSet = sampleToGenes.get(sample);
                if (geneSet == null) {
                    geneSet = new HashSet<String>();
                    sampleToGenes.put(sample, geneSet);
                }
                geneSet.add(gene);
            }
        }
        System.out.println("Total samples in CNVs: " + sampleToGenes.size());
        return sampleToGenes;
    }
    
    @Test
    public void annotateClusters() throws Exception {
        //String clusterFileName = OVARIAN_RESULT_DIR + "ClustersForAlteredGenes090809.txt";
        //String clusterFileName = OVARIAN_DIR_NAME + "GeneClustersInSampleToAlteredGenes122109.txt";
        //String clusterFileName = OVARIAN_DIR_NAME + "ClustersForMutatedGenes_Sample_2_032210.txt";
        //String clusterFileName = OVARIAN_DIR_NAME  + "ClustersForTTestGenesBatch9_15.txt";
        Map<String, Set<String>> sampleToAlteredGenes = loadSampleToNonSynonymousMutatedGenes(false);
        filterSampleToGenes(sampleToAlteredGenes, 2);
        Set<String> alteredGenes = new HashSet<String>();
        for (String sample : sampleToAlteredGenes.keySet()) {
            Set<String> genes = sampleToAlteredGenes.get(sample);
            alteredGenes.addAll(genes);
        }
        System.out.println("Total altered genes: " + alteredGenes.size());
        PathwayBasedAnnotator annotator = new PathwayBasedAnnotator();
        System.out.println("Annotate the original gene set:");
        annotator.setFDRThreshold(0.25);
        annotator.annotateGenesWithFDR(alteredGenes, AnnotationType.Pathway);
        
        System.out.println("\nAnnotate the network modules directly:");
        SpectralPartitionNetworkCluster clustering = new SpectralPartitionNetworkCluster();
        List<Set<String>> clusters = clustering.clusterGenes(alteredGenes);
        new NetworkClusterAnalyzer().annotateNetworkClusters(clusters, 10);
        
        if (true)
            return;
        System.out.println("\nAnnotate the network modules via all gene set:");
        annotator.annotateGenesWithFDR(alteredGenes, AnnotationType.Pathway);
//        SpectralPartitionNetworkCluster spectralClustering = new SpectralPartitionNetworkCluster();
//        List<Set<String>> clusters = spectralClustering.clusterGenes(alteredGenes);
        
//        NetworkClusterAnalyzer clusterAnalyzer = new NetworkClusterAnalyzer();
////        List<Set<String>> clusters = clusterAnalyzer.loadNetworkClusters(clusterFileName);
//        System.out.println("Annotating with pathways:");
//        int sizeCutoff = 10;
//        clusterAnalyzer.annotateNetworkClusters(clusters, sizeCutoff);
//        PathwayBasedAnnotator annotator = new PathwayBasedAnnotator();
//        annotator.setFDRThreshold(0.25);
//        System.out.println("\n\nAnnotating with GO:");
//        int index = 0;
//        for (Set<String> cluster : clusters) {
//            if (cluster.size() < sizeCutoff)
//                continue;
//            System.out.println("Cluster " + index + ": " + cluster.size());
//            annotator.annotateGenesUsingGOWithFDR(cluster,
//                                                  "CC");
//            index ++;
//            System.out.println();
//        }
    }
    
    /**
     * Check the samples in the clusters.
     * @throws Exception
     */
    @Test
    public void clusterAlteredGenes() throws Exception {
        //Map<String, Set<String>> sampleToAlteredGenes = loadSampleToAlteredGenes();
        Map<String, Set<String>> sampleToAlteredGenes = loadSampleToNonSynonymousMutatedGenes(false);
        filterSampleToGenes(sampleToAlteredGenes, 2);
        Set<String> alteredGenes = new HashSet<String>();
        for (String sample : sampleToAlteredGenes.keySet()) {
            Set<String> genes = sampleToAlteredGenes.get(sample);
            alteredGenes.addAll(genes);
        }
        System.out.println("Total altered genes: " + alteredGenes.size());
        Set<String> fis = fu.loadInteractions(R3Constants.GENE_FI_BIG_COMP_FILE_NAME);
        Set<String> fisInGenes = InteractionUtilities.getFIs(alteredGenes, fis);
        alteredGenes.retainAll(InteractionUtilities.grepIDsFromInteractions(fis));
        System.out.println("Genes contained by FI network: " + alteredGenes.size());
        System.out.println("Total FIs: " + fisInGenes.size());
        Set<String> genesInFIs = InteractionUtilities.grepIDsFromInteractions(fisInGenes);
        System.out.println("Total genes in FIs: " + genesInFIs.size());
//        String fileName = OVARIAN_DIR_NAME  +"FIsInMutatedGenes_2Samples_050510.txt";
//        fu.saveInteractions(fisInGenes, fileName);
        SpectralPartitionNetworkCluster clustering = new SpectralPartitionNetworkCluster();
        List<Set<String>> clusters = clustering.cluster(fisInGenes);
        for (int i = 0; i < clusters.size(); i++) {
            System.out.println(i + "\t" + clusters.get(i).size());
            System.out.println(clusters.get(i));
        }
        //fileName = OVARIAN_DIR_NAME + "ClustersForMutatedGenes_2Samples_050510.txt";
        String fileName = OVARIAN_DIR_NAME + "ClustersForAlteredGenes_2Samples_060110.txt";
        new NetworkClusterAnalyzer().outputNetworkClusters(clusters, fileName);
//        if (true)
//            return;
//        NetworkModularityCalculator calculator = new NetworkModularityCalculator();
//        List<NetworkModule> modules = calculator.calculateClusterModularityWithFDR(alteredGenes, 
//                                                                                   true,
//                                                                                   0);
//        System.out.println("Index\tSize\tModularity\tNomial_P_value\tFDR");
//        for (NetworkModule module : modules) {
//            System.out.println(module.getIndex() + "\t" + module.getIds().size()  + "\t" + 
//                               module.getModularity() + "\t" + 
//                               module.getNomialPvalue() + "\t" + module.getFDR());
//        }
//        List<NetworkModule> modules1 = calculator.calculateClusterModularityWithFDR(alteredGenes, 
//                                                                                   false, 
//                                                                                   0);
//        List<Set<String>> clusters = calculator.convertModuleObjectToSet(modules);
//        List<Set<String>> clusters1 = calculator.convertModuleObjectToSet(modules1);
//        System.out.println("\nOverlapping between two clustering reuslts with or without the ZNF clique:");
//        NetworkClusterAnalyzer clusterAnalyzer = new NetworkClusterAnalyzer();
//        clusterAnalyzer.checkNetworkModuleOverlapping(clusters,
//                                                      clusters1,
//                                                      4, 
//                                                      0.01,
//                                                      alteredGenes);
//        System.out.println();
        //if (true)
        //    return;
//        
//        
////        String clusterFileName = OVARIAN_DIR_NAME + "MCLForAlteredGenes032210.txt";
////        List<Set<String>> clusters = clusterAnalyzer.loadNetworkClusters(clusterFileName);
////        List<Set<String>> clusters = clusterAnalyzer.cluster(alteredGenes, 0.20); 
////                                                             0.10); // Tried with 0.10: too many genes without filtering
////        //String clusterFileName = OVARIAN_DIR_NAME + "ClustersForAlteredGenes090809.txt";
////        String clusterFileName = OVARIAN_DIR_NAME + "ClustersForAlteredGenes032210.txt";
////        String clusterFileName = OVARIAN_DIR_NAME + "ClustersForMutatedGenes_edge_020_032210.txt";
//        long time1 = System.currentTimeMillis();
//        //List<Set<String>> clusters = new SpectralPartitionNetworkCluster().cluster(fisInGenes);
//        List<Set<String>> clusters = clusterAnalyzer.cluster(alteredGenes);
//        long time2 = System.currentTimeMillis();
//        System.out.println("Time for clusters: " + (time2 - time1));
//        double modularity = clusterAnalyzer.calculateModularity(clusters, fisInGenes);
//        System.out.println("Modularity: " + modularity);
//        //String clusterFileName = OVARIAN_DIR_NAME + "ClustersForMutatedGenesSpectral_2Sample_040110.txt";
//        String clusterFileName = OVARIAN_DIR_NAME + "ClustersForMutatedGenesEdge_2Sample_040210.txt";
//        clusterAnalyzer.outputNetworkClusters(clusters, clusterFileName);
//        // Check the sizes of clusters
//        int index = 0;
//        System.out.println("Cluster sizes:");
//        for (Set<String> cluster : clusters) {
//            System.out.println(index + ": " + cluster.size());
//            index ++;
//        }
        // Check the distribution of samples in the clusters
        int countInCluster0And1 = 0;
        System.out.println("Sample in clusters:");
        Map<String, List<Integer>> sampleToClusters = new HashMap<String, List<Integer>>();
        for (String sample : sampleToAlteredGenes.keySet()) {
            Set<String> genes = sampleToAlteredGenes.get(sample);
            List<Integer> touched = new ArrayList<Integer>();
            for (int i = 0; i < clusters.size(); i++) {
                Set<String> cluster = clusters.get(i);
                Set<String> shared = new HashSet<String>(cluster);
                shared.retainAll(genes);
                if (shared.size() > 0)
                    touched.add(i);
            }
            if (touched.contains(0) && touched.contains(1)) {
                countInCluster0And1 ++;
            }
            System.out.println(sample + ": " + touched);
            sampleToClusters.put(sample, touched);
        }
        double percent = countInCluster0And1 / (double) sampleToAlteredGenes.size();
        System.out.println("Samples in cluster 0 and 1: " + countInCluster0And1 + " (" + percent + ")");
        // Check for each clusters
        for (int i = 0; i < clusters.size(); i++) {
            if (clusters.get(i).size() < 4)
                continue;
            int total = 0;
            for (String sample : sampleToClusters.keySet()) {
                List<Integer> touched = sampleToClusters.get(sample);
                if (touched.contains(i))
                    total ++;
            }
            percent = total / (double) sampleToAlteredGenes.size();
            System.out.println("Samples in cluster " + i + ": " + percent);
        }
    }
    
    @Test
    public void checkSamplesInNetworkModules() throws Exception {
        Map<String, Set<String>> sampleToAlteredGenes = loadSampleToNonSynonymousMutatedGenes(false);
        NetworkClusterAnalyzer clusterAnalyzer = new NetworkClusterAnalyzer();
        //String clusterFileName = OVARIAN_DIR_NAME + "MCLForFIsInMutatedGenes032210.txt";
        String clusterFileName = OVARIAN_DIR_NAME  + "ClustersForMutatedGenesSpectral_2Sample_040110.txt";
        List<Set<String>> clusters = clusterAnalyzer.loadNetworkClusters(clusterFileName);
        
        int index = 0;
        System.out.println("Module\tModue_Size\tPercentage_of_Samples_In_Module");
        for (Set<String> cluster : clusters) {
            if (cluster.size() < 20) {
                index ++;
                continue;
            }
            int contained = 0;
            for (String sample : sampleToAlteredGenes.keySet()) {
                Set<String> altered = sampleToAlteredGenes.get(sample);
                Set<String> shared = InteractionUtilities.getShared(altered, 
                                                                    cluster);
                if (shared.size() > 0)
                    contained ++;
            }
            System.out.println(index + "\t" +
                               cluster.size() + "\t" + 
                               contained + "\t" +
                               + (double) contained / sampleToAlteredGenes.size());
            index ++;
        }
        
        int countInCluster0And1 = 0;
        System.out.println("Sample in clusters:");
        Map<String, List<Integer>> sampleToClusters = new HashMap<String, List<Integer>>();
        for (String sample : sampleToAlteredGenes.keySet()) {
            Set<String> genes = sampleToAlteredGenes.get(sample);
            List<Integer> touched = new ArrayList<Integer>();
            for (int i = 0; i < clusters.size(); i++) {
                Set<String> cluster = clusters.get(i);
                Set<String> shared = new HashSet<String>(cluster);
                shared.retainAll(genes);
                if (shared.size() > 0)
                    touched.add(i);
            }
            if ((touched.contains(0) || touched.contains(4)) && touched.contains(1)) {
                countInCluster0And1 ++;
            }
            System.out.println(sample + ": " + touched);
            sampleToClusters.put(sample, touched);
        }
        double percent = countInCluster0And1 / (double) sampleToAlteredGenes.size();
        System.out.println("Samples in cluster 0 and 1: " + countInCluster0And1 + " (" + percent + ")");
        // Check for each clusters
        for (int i = 0; i < clusters.size(); i++) {
            if (clusters.get(i).size() < 20)
                continue;
            int total = 0;
            for (String sample : sampleToClusters.keySet()) {
                List<Integer> touched = sampleToClusters.get(sample);
                if (touched.contains(i))
                    total ++;
            }
            percent = total / (double) sampleToAlteredGenes.size();
            System.out.println("Samples in cluster " + i + ": " + percent);
        }
    }
    
    /**
     * This method is used to load sample to altered genes (mutated and CNV genes).
     * @return
     * @throws IOException
     */
    protected Map<String, Set<String>> loadSampleToAlteredGenes() throws IOException {
        //Map<String, Set<String>> sampleToMutatedGenes = loadSampleToMutatedGenes();
        Map<String, Set<String>> sampleToMutatedGenes = loadSampleToNonSynonymousMutatedGenes(false);
        Map<String, Set<String>> sampleToCNVGenes = loadSampleToCNVGenes();
        //System.out.println("Total samples in CNVs: " + sampleToCNVGenes.size());
        // Need to parse the sample names for a little bit
//        Map<String, Set<String>> newSampleToCNVGenes = new HashMap<String, Set<String>>();
//        for (String sample : sampleToCNVGenes.keySet()) {
//            String newSample = sample.substring(0, 12);
//            Set<String> cnvGenes = sampleToCNVGenes.get(sample);
//            newSampleToCNVGenes.put(newSample, cnvGenes);
//        }
        //System.out.println("Total samples after parsing: " + newSampleToCNVGenes.size());
        Map<String, Set<String>> sampleToAlteredGenes = new HashMap<String, Set<String>>();
        // Get genes in all samples
        //List<String> samples = new ArrayList<String>(sampleToMutatedGenes.keySet());
        Set<String> samples = loadSharedSamplesInCNVAndMutation();
        System.out.println("Total samples: " + samples.size());
        for (String sample : samples) {
            Set<String> genes = new HashSet<String>();
            Set<String> cnvGenes = sampleToCNVGenes.get(sample);
            if (cnvGenes == null) {
                //System.out.println(sample + " has no CNV genes!");
            }
            else
                genes.addAll(cnvGenes);
            Set<String> mutatedGenes = sampleToMutatedGenes.get(sample);
            if (mutatedGenes != null)
                genes.addAll(mutatedGenes);
            sampleToAlteredGenes.put(sample, genes);
        }
        return sampleToAlteredGenes;
    }
    
    @Test
    public void testLoadSampleToAlteredGenes() throws IOException {
        Map<String, Set<String>> sampleToAlteredGenes = loadSampleToAlteredGenes();
        System.out.println("Total samples in altered samples: " + sampleToAlteredGenes.size());
        Set<String> totalGenes = new HashSet<String>();
        for (String sample : sampleToAlteredGenes.keySet()) {
            Set<String> genes = sampleToAlteredGenes.get(sample);
            totalGenes.addAll(genes);
        }
        System.out.println("Total genes: " + totalGenes.size());
    }
    
    /**
     * This method is used to check the total samples in both CNV and mutated samples
     * @throws IOException
     */
    @Test
    public void checkTotalSamples() throws IOException {
        // Samples in the mutated file
        String fileName = OVARIAN_DIR_NAME + "data_110609/mutation_summary_20091112.txt";
        fu.setInput(fileName);
        Set<String> mutatedSamples = new HashSet<String>();
        String line = fu.readLine();
        while ((line = fu.readLine()) != null) {
            String[] tokens = line.split("\t");
            //System.out.println(line);
            // Just want to have samples
            mutatedSamples.add(tokens[15].substring(0, 12));
        }
        fu.close();
        System.out.println("Total samples in the mutated file: " + mutatedSamples.size());
        // Samples in the CNV samples
        fileName = OVARIAN_DIR_NAME + "data_110609/MSKCC_GISTIC_Symbol.txt";
        fu.setInput(fileName);
        Set<String> cnvSamples = new HashSet<String>();
        line = fu.readLine();
        String[] tokens = line.split("\t");
        for (int i = 1; i < tokens.length; i++)
            cnvSamples.add(tokens[i]);
        fu.close();
        System.out.println("Total samples in the CNV file: " + cnvSamples.size());
        // See the shared samples
        Set<String> sharedSamples = InteractionUtilities.getShared(mutatedSamples, cnvSamples);
        System.out.println("Shared samples: " + sharedSamples.size());
        // Check samples that are not shared:
        Set<String> copy = new HashSet<String>(mutatedSamples);
        copy.removeAll(sharedSamples);
        System.out.println("Not shared mutated samples: " + copy);
        copy = new HashSet<String>(cnvSamples);
        copy.removeAll(sharedSamples);
        System.out.println("Not shared CNV samples: " + copy);
        
        // Check samples having mutated genes and CNV genes
        Map<String, Set<String>> sampleToMutatedGenes = loadSampleToNonSynonymousMutatedGenes(true);
        System.out.println("Samples in the mutation map: " + sampleToMutatedGenes.size());
        Map<String, Set<String>> sampleToCNVGenes = loadSampleToCNVGenes();
        System.out.println("Samples in the CNV map: " + sampleToCNVGenes.size());
        sharedSamples = InteractionUtilities.getShared(sampleToMutatedGenes.keySet(),
                                                sampleToCNVGenes.keySet());
        System.out.println("Shared samples in the two maps: " + sharedSamples.size());
        sharedSamples = InteractionUtilities.getShared(sampleToMutatedGenes.keySet(), cnvSamples);
        System.out.println("Sampled in the mutation map shared with all CNV samples: " + sharedSamples.size());
        // Get a combined map for sequence altered genes
        sharedSamples = InteractionUtilities.getShared(mutatedSamples, cnvSamples);
        Set<String> toBeUsed = new HashSet<String>();
        for (String sample : sharedSamples) {
            if (sampleToMutatedGenes.containsKey(sample) ||
                sampleToCNVGenes.containsKey(sample))
                toBeUsed.add(sample);
        }
        System.out.println("Samples to be used in the altered samples: " + toBeUsed.size());
    }
    
    private Set<String> loadSharedSamplesInCNVAndMutation() throws IOException {
        // Samples in the mutated file
        Set<String> mutatedSamples = fu.loadInteractions(SEQUENCE_SAMPLE_FILE);
        System.out.println("Total samples in the mutated file: " + mutatedSamples.size());
        // Samples in the CNV samples
        String fileName = OVARIAN_DIR_NAME + "data_031910/CNVs/b9_15.all_thresholded.by_genes.mskcc.newer_cnv_list.b9_15_ts0.08.txt";
        fu.setInput(fileName);
        Set<String> cnvSamples = new HashSet<String>();
        String line = fu.readLine();
        String[] tokens = line.split("\t");
        for (int i = 3; i < tokens.length; i++) {
            cnvSamples.add(tokens[i].substring(0, 12));
        }
        fu.close();
        System.out.println("Total samples in the CNV file: " + cnvSamples.size());
        // See the shared samples
        Set<String> sharedSamples = InteractionUtilities.getShared(mutatedSamples, cnvSamples);
        System.out.println("Shared samples: " + sharedSamples.size());
        mutatedSamples.removeAll(sharedSamples);
        System.out.println("Sequenced samples not in CNV:");
        for (String sample : mutatedSamples)
            System.out.println(sample);
        return sharedSamples;
    }
    
    /**
     * This method is used to generate a list of genes involved in CNVs.
     * @throws IOExeption
     */
    @Test
    public void generateCNVGenes() throws IOException {
        //int totalSamples = 151;
        Map<String, List<String>> deletedGeneToSamples = getDeletedGeneToSamples();
        Map<String, List<String>> amplifiedGeneToSamples = getAmplifiedGeneToSamples();
        // Check distribution
        Map<Integer, Set<String>> sampleToDeletedGeneSet = generateSampleToGeneSet(deletedGeneToSamples);
        Map<Integer, Set<String>> sampleToAmplifedGeneSet = generateSampleToGeneSet(amplifiedGeneToSamples);
        System.out.println("CNV Deleted Genes:");
        outputSampleToCNVGenes(sampleToDeletedGeneSet);
        System.out.println("CNV Amplified Genes:");
        outputSampleToCNVGenes(sampleToAmplifedGeneSet);
//        // Want to calculate average shortest path among deleted genes at certain level
//        Set<String> fis = fu.loadInteractions(R3Constants.GENE_FI_BIG_COMP_FILE_NAME);
//        Set<String> fiIds = InteractionUtilities.grepIDsFromInteractions(fis);
//        BreadthFirstSearch bfs = new BreadthFirstSearch();
//        Map<String, Set<String>> geneToPartners = bfs.generateIdToPartnersMap(fis);
////        double shortestPath = calculateAverageDistance(allGenes, bfs, geneToPartners);
////        System.out.println("All\t0\t" + allGenes.size() + "\t" + shortestPath);
//        for (Integer number : list) {
//            if (number < 90)
//                continue;
//            Set<String> allGenes = new HashSet<String>();
//            for (Integer tmp : list) {
//                if (tmp < number)
//                    continue;
//                Set<String> set = sampleToAmplifedGeneSet.get(tmp);
//                if (set != null)
//                    allGenes.addAll(set);
//                set = sampleToDeletedGeneSet.get(tmp);
//                if (set != null)
//                    allGenes.addAll(set);
//            }
//            System.out.println("All genes: " + allGenes.size());
//            double shortestPath = calculateAverageDistance(allGenes,
//                                                    bfs,
//                                                    geneToPartners);
//            System.out.println(number + "\t" + 
//                               allGenes.size() + "\t" +
//                               shortestPath);
//        }
    }

    private void outputSampleToCNVGenes(Map<Integer, Set<String>> sampleToGeneSet) {
        List<Integer> list = new ArrayList<Integer>(sampleToGeneSet.keySet());
        Collections.sort(list);
        for (Integer number : list) 
            System.out.println(number + "\t" + sampleToGeneSet.get(number).size());
    }

    private Map<Integer, Set<String>> generateSampleToGeneSet(Map<String, List<String>> deletedGeneToSamples) {
        Map<Integer, Set<String>> sampleToGeneSet = new HashMap<Integer, Set<String>>();
        for (String gene : deletedGeneToSamples.keySet()) {
            List<String> samples = deletedGeneToSamples.get(gene);
            Set<String> geneSet = sampleToGeneSet.get(samples.size());
            if (geneSet == null) {
                geneSet = new HashSet<String>();
                sampleToGeneSet.put(samples.size(), geneSet);
            }
            geneSet.add(gene);
        }
        return sampleToGeneSet;
    }
    
    private double calculateAverageDistance(Set<String> geneSet,
                                            BreadthFirstSearch bfs,
                                            Map<String, Set<String>> geneToPartners) {
        Map<String, Integer> distanceMap = calculateDistances(new ArrayList<String>(geneSet),
                                                              bfs,
                                                              geneToPartners);
        int total = 0;
        for (String key : distanceMap.keySet())
            total += distanceMap.get(key);
        return (double) total / distanceMap.size();
    }
    
    @Test
    public void checkSamplesInCNVFile() throws IOException {
        String fileName = OVARIAN_DIR_NAME + "GeneMap-for-HMS_Rae_unified_ids_GeneIDs_20090430.txt";
        checkSamples(fileName);
    }
    
    private Map<String, List<String>> getAmplifiedGeneToSamples() throws IOException {
        List<String> symbols = new ArrayList<String>();
        //symbols.add("1");
        symbols.add("2");
        return getCNVGeneToSamples(symbols);
    }
    
    private Map<String, List<String>> getDeletedGeneToSamples() throws IOException {
        List<String> symbols = new ArrayList<String>();
        //symbols.add("-1");
        symbols.add("-2");
        return getCNVGeneToSamples(symbols);
    }

    private Map<String, List<String>> getCNVGeneToSamples(List<String> symbols) throws IOException {
        //String fileName = OVARIAN_DIR_NAME + "GeneMap-for-HMS_Rae_unified_ids_GeneIDs_20090430.txt";
        //String fileName = OVARIAN_DIR_NAME + "data_110609/MSKCC_GISTIC_Symbol.txt";
        String fileName = OVARIAN_DIR_NAME + "data_031910/CNVs/b9_15.all_thresholded.by_genes.mskcc.newer_cnv_list.b9_15_ts0.08.txt";
        fu.setInput(fileName);
        String line = fu.readLine();
        String[] headers = line.split("\t");
        System.out.println("Total samples in the CNV file: " + (headers.length - 1));
        Map<String, List<String>> geneToSamples = new HashMap<String, List<String>>();
        while ((line = fu.readLine()) != null) {
            String[] tokens = line.split("\t");
            String gene = tokens[0];
            List<String> list = new ArrayList<String>();
            for (int i = 1; i < tokens.length; i++) {
                if (symbols.contains(tokens[i])) {
                    list.add(headers[i]);
                }
            }
            if (geneToSamples.containsKey(gene)) {
                //System.out.println("Duplicated genes: " + gene);
                // Choose one line with highest change
                List<String> otherList = geneToSamples.get(gene);
                if (otherList.size() < list.size())
                    geneToSamples.put(gene, list);
            }
            else
                geneToSamples.put(gene, list);
        }
        //System.out.println("Total genes in CNVs: " + geneToSamples.size());
        return geneToSamples;
    }
    
    /**
     * Check samples used in the GeneExpression file.
     * @throws IOException
     */
    @Test
    public void checkSamplesInGeneExpFile() throws IOException {
        //String fileName = OVARIAN_DIR_NAME + "ovUnifiedScaled_.txt";
        checkSamples(GENE_EXP_FILE);
    }

    private void checkSamples(String fileName) throws IOException {
        fu.setInput(fileName);
        String line = fu.readLine();
        String[] samples = line.split("\t");
        System.out.println("Total samples: " + (samples.length - 1));
        // Use a list to sort
        List<String> sampleList = new ArrayList<String>();
        for (int i = 1; i < samples.length; i++) {
            //System.out.println(samples[i]);
            sampleList.add(samples[i]);
        }
        fu.close();
        Collections.sort(sampleList);
        for (String sample : sampleList)
            System.out.println(sample);
    }
    
    @Test
    public void checkExcludeIncludeSamples() throws IOException {
        String dirName = OVARIAN_DIR_NAME + "data_072610/";
        String fileName = dirName + "TCGA_ovarianUseAndExcludeList.txt";
        Set<String> included = new HashSet<String>();
        Set<String> excluded = new HashSet<String>();
        fu.setInput(fileName);
        String line = fu.readLine();
        int total = 0;
        while ((line = fu.readLine()) != null) {
            String[] tokens = line.split("\t");
            if (tokens[1].equals("Include"))
                included.add(tokens[0]);
            else if (tokens[1].equals("Exclude"))
                excluded.add(tokens[0]);
            total ++;
        }
        fu.close();
        System.out.println("Total samples: " + total);
        System.out.println("Included: " + included.size());
        System.out.println("Excluded: " + excluded.size());
        // The following statements are used to check sequenced samples
        // new sequence file download in July, 2010
        String seqSampleFile = dirName + "TCGA_OV_EXOME_CAPTURE_SAMPLE_LIST.071610.txt";
        Set<String> newSeqSamples = fu.loadInteractions(seqSampleFile);
        System.out.println("New seq samples: " + newSeqSamples.size());
        newSeqSamples.removeAll(excluded);
        System.out.println("Removing excluded samples: " + newSeqSamples.size());
        // Old seq sample file download in March, 2010
        seqSampleFile = OVARIAN_DIR_NAME + "data_031910/SampleList/sequenced_3_16_2010.txt";
        Set<String> oldSeqSamples = fu.loadInteractions(seqSampleFile);
        System.out.println("Old seq samples: " + oldSeqSamples.size());
        oldSeqSamples.removeAll(excluded);
        System.out.println("Removing excluded samples: " + oldSeqSamples.size());
        // Shared samples
        Set<String> shared = InteractionUtilities.getShared(newSeqSamples, oldSeqSamples);
        System.out.println("Shared samples: " + shared.size());
    }
    
    @Test
    public void processGeneExpFile() throws Exception {
        String fileName = OVARIAN_DIR_NAME + "ovarianpathways.txt";
        String outFileName = OVARIAN_DIR_NAME + "ovarianpathways_genes.txt";
        fu.setInput(fileName);
        FileUtility outFu = new FileUtility();
        outFu.setOutput(outFileName);
        String line = fu.readLine();
        outFu.printLine(line);
        int index = 0;
        StringBuilder builder = new StringBuilder();
        while ((line = fu.readLine()) != null) {
            String[] tokens = line.split("\t");
            String gene = tokens[0];
            index = gene.indexOf("|");
            gene = gene.substring(0, index);
            builder.append(gene);
            for (int i = 1; i < tokens.length; i++)
                builder.append("\t").append(tokens[i]);
            outFu.printLine(builder.toString());
            builder.setLength(0);
        }
        outFu.close();
        fu.close();
    }
    
    /**
     * Load gene expression data per gene. The value is stored as sample to value.
     * @return
     * @throws IOException
     */
    public Map<String, Map<String, Double>> loadGeneExp() throws IOException {
        return new CancerGeneExpressionCommon().loadGeneExp(GENE_EXP_FILE);
    }
    
    @Test
    public void checkPlatinumSamples() throws IOException {
        String[] fileNames = new String[] {
                "OvarianPlatinumResistant.txt",
                "OvarianPlatinumSensitive.txt"
        };
        Set<String> samples = new HashSet<String>();
        for (String fileName : fileNames) {
            fu.setInput(OVARIAN_DIR_NAME + fileName);
            String line = fu.readLine();
            while ((line = fu.readLine()) != null) {
                String[] tokens = line.split(":");
                samples.add(tokens[2].trim());
            }
            fu.close();
        }
        System.out.println("Total platinum samples: " + samples.size());
        //for (String sample : samples) {
        //    System.out.println(sample);
        //}
        // Check if these samples are in the array data set
        String srcFileName = OVARIAN_DIR_NAME + "ovarianpathways_genes.txt";
        fu.setInput(srcFileName);
        String line = fu.readLine();
        String[] arraySamples = line.split("\t");
        int c = 0;
        boolean isFound = false;
        for (String sample : samples) {
            isFound = false;
            for (String arraySample : arraySamples) {
                if (arraySample.startsWith(sample)) {
                    c ++;
                    isFound = true;
                    break;
                }
            }
            if (!isFound)
                System.out.println("Not in array: " + sample);
        }
        System.out.println("Samples in the array data set: " + c);
    }
    
    public Map<String, Set<String>> loadSampleToDiffGenes(boolean up) throws IOException {
        Map<String, Set<String>> sampleToDiffGenes = new HashMap<String, Set<String>>();
        String fileName = OVARIAN_DIR_NAME + "gene_exp_p_values.txt";
        fu.setInput(fileName);
        String line = fu.readLine();
        String[] samples = line.split("\t");
        double pvalueCutoff = 1.0E-15;
        int index = 0;
        String type = null;
        while ((line = fu.readLine()) != null) {
            String[] tokens = line.split("\t");
            String gene = tokens[0];
            for (int i = 1; i < samples.length; i++) {
                index = tokens[i].indexOf(":");
                type = tokens[i].substring(index + 1);
                // Just want to have pvale
                double pvalue = Double.parseDouble(tokens[i].substring(0, index));
                if (pvalue > pvalueCutoff)
                    continue;
                if (up && type.equals("+"))
                    InteractionUtilities.addElementToSet(sampleToDiffGenes, 
                                                         samples[i], 
                                                         gene);
                else if (!up && type.equals("-"))
                    InteractionUtilities.addElementToSet(sampleToDiffGenes, 
                                                         samples[i], 
                                                         gene);
            }
        }
        fu.close();
        return sampleToDiffGenes;
    }
    
    @Test
    public void testLoadSampleToDiffGenes() throws IOException {
        Map<String, Set<String>> sampleToDiffGenes = loadSampleToDiffGenes(true);
        System.out.println("Total sample numbers: " + sampleToDiffGenes.size());
        for (String sample : sampleToDiffGenes.keySet()) {
            Set<String> genes = sampleToDiffGenes.get(sample);
            System.out.println(sample + ": " + genes.size());
        }
    }
    
    /**
     * Use this method to generate pvalue matrix for t-test.
     * @throws Exception
     */
    @Test
    public void generateTTestMatrixFromGeneExp() throws Exception {
        String srcFileName = OVARIAN_DIR_NAME + "ovarianpathways_genes.txt";
        fu.setInput(srcFileName);
        String line = fu.readLine();
        String[] samples = line.split("\t");
        // The last ten samples are negative controls
        int maxSampleIndex = samples.length - 10;
        String outFileName = OVARIAN_DIR_NAME + "gene_exp_p_values.txt";
        // Last 10 samples are normal control
        FileUtility outFu = new FileUtility();
        outFu.setOutput(outFileName);
        outFu.printLine(line);
        StringBuilder builder = new StringBuilder();
        while ((line = fu.readLine()) != null) {
            String[] tokens = line.split("\t");
            builder.append(tokens[0]);
            // Get the control values
            double[] controls = new double[10];
            double controlAvg = 0.0d;
            int index = 0;
            for (int i = samples.length - 10; i < samples.length; i++) {
                double value = Double.parseDouble(tokens[i]);
                controls[index] = value;
                controlAvg += value;
            }
            controlAvg /= 10;
            for (int i = 1; i < samples.length - 10; i ++) {
                double value = Double.parseDouble(tokens[i]);
                double pvalue = TestUtils.tTest(value, controls);
                builder.append("\t").append(pvalue);
                // The direction
                builder.append(":");
                if (value < controlAvg)
                    builder.append("-");
                else
                    builder.append("+");
            }
            outFu.printLine(builder.toString());
            builder.setLength(0);
        }
        outFu.close();
    }
    
    /**
     * This method is used to remove rows with NA values
     * @throws IOExeption
     */
    @Test
    public void filterExpFile() throws IOException {
        String fileName = OVARIAN_DIR_NAME + "ovUnifiedScaled_.txt";
        fu.setInput(fileName);
        String outFileName = OVARIAN_DIR_NAME + "ovUnifiedScaled_filtered.txt";
        FileUtility outFu = new FileUtility();
        outFu.setOutput(outFileName);
        String line = fu.readLine();
        outFu.printLine(line);
        int originalTotal = 0;
        int newTotal = 0;
        while ((line = fu.readLine()) != null) {
            originalTotal ++;
            if (line.contains("NA"))
                continue;
            outFu.printLine(line);
            newTotal++;
        }
        fu.close();
        outFu.close();
        System.out.println("Original total: " + originalTotal);
        System.out.println("New total: " + newTotal);
    }
    
    /**
     * The following analysis dosn't make any sense since TCGA GBM has analyzed 600 genes only.
     * @throws Exception
     */
    @Test
    public void checkOVMutationModuleOnGBM() throws Exception {
        String clinFileName = TCGA_GBM_DIR_NAME + "TCGA_Clinical_Info_090909/tcga_GBM_clinical_csv_tab.txt";
        // For TCGA genes
        NatureGBMAnalyzer gbmAnalyzer = new NatureGBMAnalyzer();
        List<String> samples = gbmAnalyzer.loadResequencedSamples();
        System.out.println("Total re-sequenced TCGA GBM samples: " + samples.size());
        Map<String, Set<String>> sampleToGenes = gbmAnalyzer.getSampleToAlteredGenes(samples);
//        Map<String, Set<String>> sampleToGenes = new NatureGBMAnalyzer().loadSampleToMutations();
        System.out.println("Total samples: " + sampleToGenes.size());
        runSurvivalAnalysisForMutatedSamples(clinFileName, sampleToGenes);
    }
    
    @Test
    public void generateSamplesToGeneExpressionNotInCombinedModules() throws Exception {
        String clinFileName = OVARIAN_DIR_NAME + "data_published_in_nature/2010-09-11380C-Table_S1.2_with_edit.txt";
        Map<String, Set<String>> sampleToGenes = loadSampleToNonSynonymousMutatedGenes(false);
        System.out.println("Total samples: " + sampleToGenes.size());
        
        Set<String> module6Plus7 = fu.loadInteractions(OVARIAN_DIR_NAME + "data_published_in_nature/GenesInModules6And7.txt");
        Set<String> notMutatedSamples = new HashSet<String>();
        for (String sample : sampleToGenes.keySet()) {
            Set<String> mutatedGenes = sampleToGenes.get(sample);
            Set<String> shared = InteractionUtilities.getShared(mutatedGenes, module6Plus7);
            if (shared.size() == 0)
                notMutatedSamples.add(sample);
        }
        System.out.println("Samples Not mutated: " + notMutatedSamples.size());
        
        // Re-genreated file
        String srcFile = OVARIAN_DIR_NAME + "data_072610/TCGA_batch9-15_17-19_21-22_24.UE.No_Normal.txt";
        String targetFile = OVARIAN_DIR_NAME + "data_published_in_nature/TCGA_batch9-15_17-19_21-22_24.UE.No_Normal.No_Mutated_in_Module6_7.txt";
        fu.setInput(srcFile);
        fu.setOutput(targetFile);
        StringBuilder builder = new StringBuilder();
        List<Integer> selected = new ArrayList<Integer>();
        String line = fu.readLine();
        String[] tokens = line.split("\t");
        selected.add(0);
        builder.append(tokens[0]);
        for (int i = 1; i < tokens.length; i++) {
            if (notMutatedSamples.contains(tokens[i])) {
                selected.add(i);
                builder.append("\t").append(tokens[i]);
            }
        }
        fu.printLine(builder.toString());
        builder.setLength(0);
        while ((line = fu.readLine()) != null) {
            tokens = line.split("\t");
            for (Integer index : selected)
                builder.append(tokens[index]).append("\t");
            builder.deleteCharAt(builder.length() - 1); // Delete the last tab
            fu.printLine(builder.toString());
            builder.setLength(0);
        }
        fu.close();
    }
    
    /**
     * Check some survival analysis results.
     * @throws Exception
     */
    @Test
    public void runSurvivalAnalysisForMutatedSamples() throws Exception {
        String clinFileName = OVARIAN_DIR_NAME + "data_published_in_nature/2010-09-11380C-Table_S1.2_with_edit.txt";
        Map<String, Set<String>> sampleToGenes = loadSampleToNonSynonymousMutatedGenes(false);
        runSurvivalAnalysisForMutatedSamples(clinFileName, sampleToGenes);
    }

    protected void runSurvivalAnalysisForMutatedSamples(String clinFileName,
                                                        Map<String, Set<String>> sampleToGenes) throws IOException {
        SurvivalAnalysisHelper survivalHelper = CancerAnalysisUtilitites.getSurvivalAnalysisHelper();
        String moduleFile = OVARIAN_DIR_NAME + "data_published_in_nature/NetworkModules_101311.txt";
        NetworkClusterAnalyzer clusterAnalyzer = new NetworkClusterAnalyzer();
        List<Set<String>> modules = clusterAnalyzer.loadNetworkClusters(moduleFile);
        Set<String> module5 = modules.get(5);
        System.out.println("Module 5: " + module5.size());
        Set<String> module6 = modules.get(6);
        System.out.println("Module 6: " + module6.size());
        Set<String> module7 = modules.get(7);
        System.out.println("Module 7: " + module7.size());
        Set<String> mergedModule = new HashSet<String>(module6);
        mergedModule.addAll(module7);
        System.out.println("Total genes: " + mergedModule.size());
        System.out.println("\nModule 6:");
        doSurvivalAnalysisForMutationModule(survivalHelper, 
                                            sampleToGenes,
                                            module6,
                                            clinFileName,
                                            "Module6");
        System.out.println("\nModule 7:");
        doSurvivalAnalysisForMutationModule(survivalHelper, 
                                            sampleToGenes, 
                                            module7, 
                                            clinFileName,
                                            "Module7");
        System.out.println("\nModule 6 + Module 7:");
        doSurvivalAnalysisForMutationModule(survivalHelper, 
                                            sampleToGenes, 
                                            mergedModule, 
                                            clinFileName,
                                            "Modules6And7");
        String text = "KCNA3,DYNC1I1,PCNT,GRIA4,CACNA1F,TGFBR2,TUBA3C,MAP3K7,AKAP6,DNAH2,SYNGAP1,CACNA2D1,DLG1,KCNJ12,BMPR2,DLG2,KCNA4";
        String[] tokens = text.split(",");
        for (String token : tokens)
            mergedModule.remove(token);
//        String removedGenes = "HAP1";
//        String[] tokens = removedGenes.split(", ");
//        for (String token : tokens)
//            mergedModule.remove(token);
        System.out.println("\nModule 6 + Module 7 with trimmed:");
        doSurvivalAnalysisForMutationModule(survivalHelper, 
                                            sampleToGenes, 
                                            mergedModule, 
                                            clinFileName,
                                            "Modules6And7Trimmed");
        System.out.println();
        // Want to print out genes
        for (String gene : mergedModule)
            System.out.println(gene);
        System.out.println();
        // Just for comparison
        mergedModule.addAll(module5);
        System.out.println("\nModules 6 + 7 + 5");
        doSurvivalAnalysisForMutationModule(survivalHelper, 
                                            sampleToGenes, 
                                            mergedModule, 
                                            clinFileName,
                                            "Modules6And7and5");
    }

    /**
     * Do a module based survival analysis using the specified survival analysis model.
     * @param survivalHelper
     * @param sampleToGenes
     * @param mergedModule
     * @param clinFileName
     * @param filePrefix
     * @param model
     * @return
     * @throws IOException
     */
    public SurvivalAnalysisResult doSurvivalAnalysisForMutationModule(SurvivalAnalysisHelper survivalHelper,
                                                                      Map<String, Set<String>> sampleToGenes,
                                                                      Set<String> mergedModule,
                                                                      String clinFileName,
                                                                      String filePrefix,
                                                                      String model) throws IOException {
        String scoreFileName = createTempScoreFile(sampleToGenes,
                                                   mergedModule);
        if (scoreFileName == null)
            return null; // Nothing needs to be done!
        SurvivalAnalysisResult result = survivalHelper.doSurvivalAnalysis(new File(scoreFileName), 
                                                                          new File(clinFileName), 
                                                                          model, 
                                                                          "0", 
                                                                          null,
                                                                          false);
        return result;
    }

    /**
     * Do survival analysis using both CoxPh and Kaplan-Meier analysis
     * @param survivalHelper
     * @param sampleToGenes
     * @param mergedModule
     * @param clinFileName
     * @param filePrefix
     * @throws IOException
     */
    public void doSurvivalAnalysisForMutationModule(SurvivalAnalysisHelper survivalHelper,
                                                    Map<String, Set<String>> sampleToGenes,
                                                    Set<String> mergedModule,
                                                    String clinFileName,
                                                    String filePrefix) throws IOException {
        String scoreFileName = createTempScoreFile(sampleToGenes,
                                                   mergedModule);
        if (scoreFileName == null)
            return; // Nothing needs to be done!
        SurvivalAnalysisResult result = survivalHelper.doSurvivalAnalysis(new File(scoreFileName), 
                                                                          new File(clinFileName), 
                                                                          "coxph", 
                                                                          "0", 
                                                                          null,
                                                                          false);
        System.out.println(result.getOutput());
        
        result = survivalHelper.doSurvivalAnalysis(new File(scoreFileName), 
                                                   new File(clinFileName), 
                                                   "kaplan-meier", 
                                                   "0", 
                                                   filePrefix,
                                                   false);
        System.out.println(result.getOutput());
    }

    private String createTempScoreFile(Map<String, Set<String>> sampleToGenes,
                                       Set<String> mergedModule) throws IOException {
//        System.out.println("Total genes: " + mergedModule.size());
        // Generate a temp file
        String scoreFileName = "tmp/Score.txt";
        fu.setOutput(scoreFileName);
        fu.printLine("Sample\tScore");
        int zeroCount = 0;
        int oneCount = 0;
        for (String sample : sampleToGenes.keySet()) {
            Set<String> genes = sampleToGenes.get(sample);
            Set<String> shared = InteractionUtilities.getShared(genes, mergedModule);
            if (shared.size() > 0) {
                fu.printLine(sample + "\t1");
                oneCount ++;
            }
            else {
                fu.printLine(sample + "\t0");
                zeroCount ++;
            }
        }
        fu.close();
//        System.out.println("Zero count: " + zeroCount);
//        System.out.println("One count: " + oneCount);
        if (zeroCount == 0 || oneCount == 0) {
            System.out.println("Cannot do survival analysis: one value is 0!");
            return null;
        }
        return scoreFileName;
    }
    

}
