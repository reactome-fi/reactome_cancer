/*
 * Created on Apr 15, 2016
 *
 */
package org.reactome.r3;

import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.gk.model.GKInstance;
import org.gk.model.InstanceUtilities;
import org.gk.model.ReactomeJavaConstants;
import org.gk.persistence.MySQLAdaptor;
import org.gk.util.FileUtilities;
import org.junit.Test;

/**
 * This test class is used to generate a network of reactions. Reaction1 and Reaction2 will be linked
 * together if reaction1 is annotated as a precedingEvent of Reaction2, or one of outputs, which is not
 * a SimpleEntity in the list of ATP, ADP, Pi, H2O, GTP, GDP, CO2, H+, , is an input, catalyst, regulator of Reaction2.
 * @author gwu
 *
 */
@SuppressWarnings("unchecked")
public class ReactionMapGenerator {
    private final String DIR_NAME = "/Users/gwu/Documents/wgm/work/reactome/ReactionNetwork/";
    private Set<String> entityEscapeNames;
    
    /**
     * Default constructor.
     */
    public ReactionMapGenerator() {
    }
    
    private MySQLAdaptor getDBA() throws Exception {
//        MySQLAdaptor dba = new MySQLAdaptor("localhost",
//                                            "gk_central_041416",
//                                            "root",
//                                            "macmysql01");
        MySQLAdaptor dba = new MySQLAdaptor("localhost",
                                            "reactome_59_plus_i",
                                            "root",
                                            "macmysql01");
        return dba;
    }
    
    @Test
    public void checkMCLClusterResults() throws Exception {
        String file = DIR_NAME + "ReactionNewtork_MCL.txt";
        String outFile = DIR_NAME + "ReactionNetwork_MCL_Reaction.txt";
        FileUtilities fu = new FileUtilities();
        fu.setInput(file);
        fu.setOutput(outFile);
        fu.printLine("Reactome\tMCL_Cluster");
        String line = null;
        int cluster = 1;
        while ((line = fu.readLine()) != null) {
            String[] tokens = line.split("\t");
            System.out.println(cluster + "\t" + tokens.length);
            for (String token : tokens)
                fu.printLine(token + "\t" + cluster);
            cluster ++;
        }
        fu.close();
    }
    
    /**
     * Load a network node feature for reaction nodes. The file should be generated by Cytoscape's
     * Analyze Network... feature and exported into a simple text file.
     * @param fileName A csv file exported from Cytoscape.
     * @param featureName
     * @return
     * @throws IOException
     */
    public Map<String, Double> loadNodeFeature(String fileName,
                                               String featureName) throws IOException {
        Map<String, Double> reactionToFeature = new HashMap<String, Double>();
        Reader reader = new FileReader(fileName);
        Iterable<CSVRecord> records = CSVFormat.DEFAULT.parse(reader);
        int featureIndex = -1;
        int nameIndex = -1;
        boolean isFirst = true;
        for (CSVRecord record : records) {
            if (isFirst) {
                for (int i = 0; i < record.size(); i++) {
                    if (record.get(i).equalsIgnoreCase(featureName))
                        featureIndex = i;
                    else if (record.get(i).equalsIgnoreCase("name"))
                        nameIndex = i;
                }
                if (featureIndex == -1)
                    throw new IllegalArgumentException("Cannot find a column for " + featureName);
                if (nameIndex == -1)
                    throw new IllegalArgumentException("Cannot find a column for name!");
                isFirst = false;
            }
            else {
                reactionToFeature.put(record.get(nameIndex),
                                      new Double(record.get(featureIndex)));
            }
        }
        return reactionToFeature;
    }
    
    @Test
    public void simplifyNetwork() throws Exception {
        String source = DIR_NAME + "ReactionNetwork.txt";
        String target = DIR_NAME + "ReactionNetworkPair.txt";
        FileUtilities fu = new FileUtilities();
        fu.setInput(source);
        fu.setOutput(target);
        String line = null;
        fu.printLine("Rxt1\tRxt2");
        while ((line = fu.readLine()) != null) {
            String[] tokens = line.split(" ");
            fu.printLine(tokens[0] + "\t" + tokens[2]);
        }
        fu.close();
    }
    
    @Test
    public void generate() throws Exception {
        MySQLAdaptor dba = getDBA();
        GKInstance human = dba.fetchInstance(48887L); 
        // Load instances
        Collection<GKInstance> reactions = dba.fetchInstanceByAttribute(ReactomeJavaConstants.ReactionlikeEvent,
                                                                        ReactomeJavaConstants.species,
                                                                        "=",
                                                                        human);
        Collection<GKInstance> regulations = dba.fetchInstancesByClass(ReactomeJavaConstants.Regulation);
        // Load attributes
        dba.loadInstanceAttributeValues(reactions, 
                                        new String[] {ReactomeJavaConstants.input,
                                                      ReactomeJavaConstants.output,
                                                      ReactomeJavaConstants.catalystActivity,
                                                      ReactomeJavaConstants.precedingEvent});
        dba.loadInstanceAttributeValues(regulations,
                                        new String[] {ReactomeJavaConstants.physicalEntity,
                                                      ReactomeJavaConstants.regulatedEntity});
        List<GKInstance> reactionList = new ArrayList<GKInstance>(reactions);
        filterReaction(reactionList);
        FileUtilities fu = new FileUtilities();
//        fu.setOutput("tmp/ReactionNetwork.txt");
//        fu.setOutput(DIR_NAME + "ReactionNetwork_082916.txt");
//        fu.setOutput(DIR_NAME + "ReactionNetwork_101316.txt");
        fu.setOutput("results/DriverGenes/Drivers_0417/ReactionNetwork_040517.txt");
        for (int i = 0; i < reactionList.size() - 1; i++) {
            GKInstance reaction1 = reactionList.get(i);
            System.out.println(i + ": " + reaction1);
            for (int j = 0; j < reactionList.size(); j++) { // Since it is possible two reactions may point to each other
                                                            // We need to check all
                GKInstance reaction2 = reactionList.get(j);
                if (i == j)
                    continue; // Escape itself
                boolean isPreceding = isPrecedingTo(reaction1, reaction2);
                if (isPreceding)
                    fu.printLine(reaction1.getDBID() + " preceding " + reaction2.getDBID());
                else {
                    isPreceding = isPrecedingTo(reaction2, reaction1);
                    if (isPreceding)
                        fu.printLine(reaction2.getDBID() + " preceding " + reaction1.getDBID());
                }
            }
        }
        fu.close();
    }
    
    /**
     * Filter reactions annotated for diseases
     * @param reactionList
     * @throws Exception
     */
    private void filterReaction(List<GKInstance> reactionList) throws Exception {
        for (Iterator<GKInstance> it = reactionList.iterator(); it.hasNext();) {
            GKInstance rxt = it.next();
            GKInstance disease = (GKInstance) rxt.getAttributeValue(ReactomeJavaConstants.disease);
            if (disease != null)
                it.remove();
        }
    }
    
    private boolean shouldEscape(GKInstance output) throws Exception {
//        if (output.getSchemClass().isa(ReactomeJavaConstants.SimpleEntity)) {
            String name = (String) output.getAttributeValue(ReactomeJavaConstants.name);
            return (getEntityEscapeNames().contains(name));
//        }
//        if (output.getSchemClass().isa(ReactomeJavaConstants.EntitySet)) {
//            List<GKInstance> hasMember = output.getAttributeValuesList(ReactomeJavaConstants.hasMember);
//            for (GKInstance hasMember1 : hasMember) {
//                if (hasMember1.getSchemClass().isa(ReactomeJavaConstants.SimpleEntity))
//                    return true;
//            }
//        }
//        return false;
    }
    
    private Set<String> getEntityEscapeNames() {
        if (entityEscapeNames != null)
            return entityEscapeNames;
        entityEscapeNames = new HashSet<String>();
        String names = "ATP, ADP, Pi, H2O, GTP, GDP, CO2, H+";
//        // Ub-based protein degradation is applied to all proteins
//        // For this analysis, we escape it
//        String names = "ATP, ADP, Pi, H2O, GTP, GDP, CO2, H+, Ub";
        String[] tokens = names.split(", ");
        for (String token : tokens)
            entityEscapeNames.add(token);
        return entityEscapeNames;
    }
    
    /**
     * Check if reaction1 is preceding to reaction2.
     * @param rxt1
     * @param rxt2
     * @return
     * @throws Exception
     */
    private boolean isPrecedingTo(GKInstance rxt1,
                                  GKInstance rxt2) throws Exception {
        // If rxt1 is in the rxt2's precedingEvent list
        List<GKInstance> precedingEvent2 = rxt2.getAttributeValuesList(ReactomeJavaConstants.precedingEvent);
        if (precedingEvent2.contains(rxt1))
            return true;
        // Check if rxt1's output is in rxt2 input, catalyst, or regulator. 
        // For this test and simplicity, only non-simple molecule entity is tested
        List<GKInstance> output1 = rxt1.getAttributeValuesList(ReactomeJavaConstants.output);
        if (output1.size() == 0)
            return false;
        for (GKInstance output : output1) {
            if (shouldEscape(output))
                continue;
            Set<GKInstance> lfhEntities = getLeftHandEntities(rxt2);
            for (GKInstance lfhEntity : lfhEntities) {
                if (shouldEscape(lfhEntity))
                    continue;
                if (isEquivalent(lfhEntity, output))
                    return true;
            }
        }
        return false;
    }
    
    @Test
    public void testIsPrecedingTo() throws Exception {
        Long preId = 450592L;
        Long folId = 450499L;
        // These two should not
        preId = 5684273L;
        folId = 451634L;
        MySQLAdaptor dba = getDBA();
        GKInstance preRxt = dba.fetchInstance(preId);
        GKInstance folRxt = dba.fetchInstance(folId);
        System.out.println(isPrecedingTo(preRxt, folRxt));
    }
    
    private boolean isEquivalent(GKInstance lfhEntity,
                                 GKInstance output) throws Exception {
        // If they are the same, return true
        if (lfhEntity == output)
            return true;
        if (output.getSchemClass().isa(ReactomeJavaConstants.EntitySet)) {
            // If output is an EntitySet having lfhEntity as a member, return true
            Set<GKInstance> members = InstanceUtilities.getContainedInstances(output,
                                                                              ReactomeJavaConstants.hasMember);
            if (members.contains(lfhEntity))
                return true;
            if (lfhEntity.getSchemClass().isa(ReactomeJavaConstants.EntitySet)) {
                // If both are EntitySets having shared member, return true
                Set<GKInstance> lfhMembers = InstanceUtilities.getContainedInstances(lfhEntity,
                                                                                     ReactomeJavaConstants.hasMember);
                lfhMembers.retainAll(members);
                if (lfhMembers.size() > 0)
                    return true; // There is at least one shared member
            }
        }
        return false;
    }
    
    private Set<GKInstance> getLeftHandEntities(GKInstance reaction) throws Exception {
        Set<GKInstance> rtn = new HashSet<GKInstance>();
        List<GKInstance> input = reaction.getAttributeValuesList(ReactomeJavaConstants.input);
        if (input != null)
            rtn.addAll(input);
        GKInstance cas = (GKInstance) reaction.getAttributeValue(ReactomeJavaConstants.catalystActivity);
        if (cas != null) {
            GKInstance ca = (GKInstance) cas.getAttributeValue(ReactomeJavaConstants.physicalEntity);
            if (ca != null)
                rtn.add(ca);
        }
        Collection<GKInstance> regulations = InstanceUtilities.getRegulations(reaction);
        if (regulations != null && regulations.size() > 0) {
            for (GKInstance regulation : regulations) {
                GKInstance regulator = (GKInstance) regulation.getAttributeValue(ReactomeJavaConstants.regulator);
                if (regulator != null)
                    rtn.add(regulator);
            }
        }
        return rtn;
    }
}
