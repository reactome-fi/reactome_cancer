/*
 * Created on May 16, 2008
 *
 */
package org.reactome.r3;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.jgrapht.Graph;
import org.jgrapht.graph.DefaultEdge;
import org.junit.Test;
import org.reactome.cancer.CancerResequenceDataSetAnalyzer;
import org.reactome.data.ProteinSequenceHandler;
import org.reactome.data.UniProtAnalyzer;
import org.reactome.fi.ExperimentalValidationTargetGenerator;
import org.reactome.fi.FunctionalInteractionAnalyzer;
import org.reactome.funcInt.DbReference;
import org.reactome.funcInt.Evidence;
import org.reactome.funcInt.Interaction;
import org.reactome.funcInt.Protein;
import org.reactome.funcInt.ReactomeSource;
import org.reactome.hibernate.HibernateFIPersistence;
import org.reactome.hibernate.HibernateFIReader;
import org.reactome.r3.graph.BreadthFirstSearch;
import org.reactome.r3.graph.BreadthFirstSearch.Edge;
import org.reactome.r3.graph.BreadthFirstSearch.TreeNode;
import org.reactome.r3.graph.GraphAnalyzer;
import org.reactome.r3.graph.JGraphTUtilities;
import org.reactome.r3.util.FileUtility;
import org.reactome.r3.util.InteractionUtilities;
import org.reactome.r3.util.MathUtilities;
import org.reactome.r3.util.R3Constants;

/**
 * This class is used to analyze the data set from Rod Bremner's group about
 * pathway interaction partners from Interferon gamma pathway, which was generated by
 * using CIITA-Luc level.
 * @author wgm
 *
 */
public class RodBremnerDataAnalyzer {
    //private final String GENE_FI_BIG_COMP_FILE_NAME = R3Constants.RESULT_DIR + "FI73InGene_102908_BigComp.txt";
    //private final String GENE_FI_BIG_COMP_FILE_NAME = R3Constants.RESULT_DIR + "FI73InGene_Remove_Hubs_110308_BigComp.txt";
    // Check with all uppercase file
    //private final String GENE_FI_BIG_COMP_FILE_NAME = "results/v2/FI73InGeneUpperCase_111208_BigComp.txt";
    private final String GENE_FI_BIG_COMP_FILE_NAME = R3Constants.GENE_FI_BIG_COMP_FILE_NAME;
    private final String DATA_SET_DIR = "datasets/Rod_IFNG/";
    private final String ORIGINAL_WT_DATA_FILE = DATA_SET_DIR + "FinalCombineddataBNCB_WT.txt";
    private final String ORIGINAL_SUPP_DATA_FILE = DATA_SET_DIR + "FinalCombineddataBNCB_SUPP.txt";
    private final double CUT_OFF = 0.73d;
    //private final double CUT_OFF = 0.0d;
    private FileUtility fu = null;
    
    public RodBremnerDataAnalyzer() {
        fu = new FileUtility();
    }
    
    @Test
    public void calculateMiniSpanGraphForProteins() throws Exception {
        Set<String> fis = fu.loadInteractions(GENE_FI_BIG_COMP_FILE_NAME);
        Set<String> allGenes = InteractionUtilities.grepIDsFromInteractions(fis);
        BreadthFirstSearch bfs = new BreadthFirstSearch();
        Map<TreeNode, List<Edge>> nodeToEdges = bfs.initGraph(fis);
        // Prepare proteins
        //List<String> validatedGenes = getValidatedGenes();
        List<String> validatedGenes = new RodBremnerArrayAnalyzer().loadDiffGenesFromFile();
        validatedGenes.retainAll(allGenes);
        System.out.println("Total validated genes in the biggest component: " + validatedGenes.size());
        CancerResequenceDataSetAnalyzer analyzer = new CancerResequenceDataSetAnalyzer();
        int path = analyzer.calculatePathForMinispanNetwork(validatedGenes);
        System.out.println("Path: " + path);
    }
    
    /**
     * Used to annotate a set of protein based on protein names.
     * @throws Exception
     */
    @Test
    public void annotateProteins() throws Exception {
        // Load genes
        List<String> genes = getValidatedGenes();
        System.out.println("Total validated genes: " + genes.size());
        List<String> targets = getIFNGCoreComponents();
        System.out.println("Target genes: " + targets.size());
        genes.removeAll(targets);
        System.out.println("Remove targets from the validated genes: " + genes.size());
        Set<String> fis = fu.loadInteractions(GENE_FI_BIG_COMP_FILE_NAME);
        Set<String> allGenes = InteractionUtilities.grepIDsFromInteractions(fis);
        genes.retainAll(allGenes);
        System.out.println("Genes in biggest component: " + genes.size());
        // Annotate
//        PathwayAnnotator topicAnalyzer = new PathwayAnnotator();
//        topicAnalyzer.setPValueThreshold(1.0);
//        System.out.println("Annotate with the original pathways:");
//        topicAnalyzer.topicAnnotateWithNames(genes, false, System.out);
//        System.out.println();
//        System.out.println("Annotate with the clustered pathways:");
//        topicAnalyzer.topicAnnotateWithNames(genes, true, System.out);
    }
    
    /**
     * This method is used to check overlap between the validated genes or other sets of genes
     * with IFNG pathway components FI partners.
     * @throws Exception
     */
    @Test
    public void checkOverlapForValdiatedGenes() throws Exception {
        List<String> targetGenes = getValidatedGenes();
        //List<String> targetGenes = new RodBremnerArrayAnalyzer().loadDiffGenesFromFile();
        //List<String> targetGenes  = getGenesForExpValidation();
        String intFileName = R3Constants.GENE_FI_BIG_COMP_FILE_NAME;
        Set<String> totalFIs = fu.loadInteractions(intFileName);
        Set<String> totalGenes = InteractionUtilities.grepIDsFromInteractions(totalFIs);
        int total = totalGenes.size();
        totalGenes.retainAll(targetGenes);
        System.out.println("Total genes: " + total);
        System.out.println("Target genes in the network: " + totalGenes.size());
        System.out.println("Total target genes: " + targetGenes.size());
        System.out.println("target genes: " + targetGenes);
        //Set<String> fiPartners = generateIFNGPathwayInteractors(true, 
        //                                                        true);
        Set<String> fiPartners = getIFNGFIPartnersFromFile(1, totalFIs);
        //System.out.println("PIK3CD: " + fiPartners.contains("PIK3CD"));
        System.out.println("FI partners: " + fiPartners.size());
        // Do some filtering
//        Map<String, Integer> geneExpData = getGeneExpressionData();
//        fiPartners.retainAll(geneExpData.keySet());
//        System.out.println("After gene expression filtering: " + fiPartners.size());
        targetGenes.retainAll(fiPartners);
        System.out.println("Overlap: " + targetGenes);
        double pvalue = MathUtilities.calculateHypergeometricPValue(total, // Total gene number
                                                                    fiPartners.size(), // interaction genes
                                                                    totalGenes.size(), // sample genes
                                                                    targetGenes.size()); // overlapping
        System.out.println("P value for overlapping: " + pvalue);
    }
    
    /**
     * This method is used to get the validated genes.
     * @return
     * @throws IOException
     */
    private List<String> getValidatedGenes() throws IOException {
        String fileName = DATA_SET_DIR + "ValidatedGeneList.txt";
        fu.setInput(fileName);
        String line = fu.readLine();
        line = fu.readLine();
        List<String> genes = new ArrayList<String>();
        while ((line = fu.readLine()) != null) {
            if (line.trim().length() == 0)
                break;
            String[] tokens = line.split("\t");
            String gene = tokens[1];
            genes.add(gene);
        }
        fu.close();
        genes.remove("RAN");
        return genes;
    }
    
    private List<String> getGenesForExpValidation() throws IOException {
        String fileName = DATA_SET_DIR + "Validation_Results.txt";
        fu.setInput(fileName);
        String line = fu.readLine();
        line = fu.readLine();
        List<String> genes = new ArrayList<String>();
        while ((line = fu.readLine()) != null) {
            if (line.trim().length() == 0)
                break;
            String[] tokens = line.split("\t");
            String gene = tokens[41];
            genes.add(gene);
            if (genes.size() == 94)
                break;
        }
        fu.close();
        return genes;
    }
    
    private void getGeneNameToUniProtMap(Session session,
                                         Map<String, String> geneNameToUniProt,
                                         Map<String, String> uniProtToGeneName) throws Exception {
        Query query =  session.createQuery("FROM Protein");
        List list = query.list();
        for (Iterator it = list.iterator(); it.hasNext();) {
            Protein protein = (Protein) it.next();
            DbReference dbreference = protein.getPrimaryDbReference();
            String name = protein.getLabel();
            String accession = dbreference.getAccession();
            geneNameToUniProt.put(name, accession);
            uniProtToGeneName.put(accession, name);
        }
    }
    
    /**
     * This method is used to mimic the original way to get predicated new FI partners
     * for IFNG in class ExpermentalValdiationTargetGenerator.
     */
    @Test
    public void filterInOriginalWay() throws Exception {
        Session session = getSession();
        Map<String, String> geneNameToUniProt = new HashMap<String, String>();
        Map<String, String> uniProtToGeneName = new HashMap<String, String>();
        getGeneNameToUniProtMap(session, geneNameToUniProt, uniProtToGeneName);
        //List<String> targetGenes = getExtendardTargetGenes();
        List<String> targetGenes = getIFNGCoreComponents();
        Set<String> targetIds = new HashSet<String>();
        for (String gene : targetGenes) {
            String id = geneNameToUniProt.get(gene);
            if (id == null) {
                System.out.println(gene + " cannot be mapped to uniprot!");
                continue;
            }
            targetIds.add(id);
        }
        ExperimentalValidationTargetGenerator generator = new ExperimentalValidationTargetGenerator();
        Set<Interaction> interactions = fetchAllInteractions(session);
        Set<String> interactorIds = generator.generateNewInteractionPartners(targetIds);
        session.close();
        System.out.println("Total interactors in ids: " + interactorIds.size());
        // Need to map it back to gene names
        Set<String> interactorGenes = new HashSet<String>();
        for (String id : interactorIds) {
            String gene = uniProtToGeneName.get(id);
            if (gene == null) {
                System.out.println(id + " cannot be mapped to gene name!");
                continue;
            }
            interactorGenes.add(gene);
        }
        System.out.println("Total interactors in genes: " + interactorGenes.size());
        String outputFileName = DATA_SET_DIR + "FilterFromInteractorsInOriginalWayNoPI.txt";
        filterDatasetBasedOnGenes(interactorGenes, outputFileName);
    }
    
    /**
     * This method is used to check the scores for pathway components and any known
     * proteins that can interact with core components.
     * @throws Exception
     */
    @Test
    public void filterBasedOnExtendedGenes() throws Exception {
        //String outFileName = DATA_SET_DIR + "FilteredForExtendedGeneList_Supp.txt";
        //String outFileName = DATA_SET_DIR + "FilteredForExtendedGeneList_Supp_091708.txt";
        String outFileName = DATA_SET_DIR + "FilteredForExtendedGeneList_WT_091708.txt";
        List<String> geneNames = getExtendardTargetGenes();
        System.out.println("Total genes: " + geneNames.size());
        filterDatasetBasedOnGenes(geneNames,
                                  outFileName);
    }
    
    /**
     * This method is used to filter the original data set based on genes in our
     * functional interaction network. Only genes in our FI network will be kept.
     */
    @Test
    public void filterDatasetBasedOnFINetwork() throws Exception {
        Set<String> geneNames = fetchGenesInFINetwork();
        //String outFileName = DATA_SET_DIR + "WTFilterBasedFIs063008.txt";
        //String outFileName = DATA_SET_DIR + "SUPPFilterBasedFIs063008.txt";
        //String outFileName = DATA_SET_DIR + "WTFilterBasedFIs091708.txt";
        String outFileName = DATA_SET_DIR + "SUPPFilterBasedFIs091708.txt";
        filterDatasetBasedOnGenes(geneNames,
                                  outFileName);
    }
    
    /**
     * This filter is based on FIs and Gene expression data sets.
     * @throws Exception
     */
    @Test
    public void filterDatasetBasedOnFIAndGeneExp() throws Exception {
        Set<String> geneNames = fetchGenesInFINetwork();
        Map<String, Integer> geneToExp = getGeneExpressionData();
        geneNames.retainAll(geneToExp.keySet());
        // Get all expressed genes
        String outFileName = DATA_SET_DIR + "WTFilterOnFIsAndExp102108.txt";
        filterDatasetBasedOnGenes(geneNames, outFileName);
    }

    private Set<String> fetchGenesInFINetwork() throws Exception {
        // Get interactions first
        Session session = getSession();
        Set<Interaction> interactions = fetchAllInteractions(session);
        // Want to get a list of gene names from our Interactions
        Set<String> geneNames = new HashSet<String>();
        for (Interaction i : interactions) {
            Protein first = i.getFirstProtein();
            geneNames.add(first.getLabel());
            Protein second = i.getSecondProtein();
            geneNames.add(second.getLabel());
        }
        session.close();
        return geneNames;
    }
    
    /**
     * This method is used to build FIs among target genes.
     * @throws Exception
     */
    @Test
    public void buildFIsAmongTargetGenes() throws Exception {
        List<String> targetGenes = getIFNGCoreComponents();
        Set<String> fis = fu.loadInteractions(GENE_FI_BIG_COMP_FILE_NAME);
        for (String fi : fis) {
            int index = fi.indexOf("\t");
            String gene1 = fi.substring(0, index);
            String gene2 = fi.substring(index + 1);
            if (targetGenes.contains(gene1) && targetGenes.contains(gene2))
                System.out.println(fi);
        }
    }
    
    private Session getSession() throws Exception {
        HibernateFIPersistence fiAnalyzer = new HibernateFIReader();
        SessionFactory sf = fiAnalyzer.initSession();
        Session session = sf.openSession();
        return session;
    }
    
    /**
     * This method is used to filter the original data set based on gene epxression
     * data set to make sure all genes have been expressed.
     * @throws IOException
     */
    @Test
    public void filterDatasetBasedOnGeneExp() throws IOException {
        Map<String, Integer> geneToExp = getGeneExpressionData();
        String outFileName = DATA_SET_DIR + "WTFilterBasedGeneExp.txt";
        filterDatasetBasedOnGenes(geneToExp.keySet(), 
                                  outFileName);
    }
    
    /**
     * A factored method to filter the original data set based on a list of gene names.
     */
    private void filterDatasetBasedOnGenes(Collection<String> genes,
                                           String outFileName) throws IOException {
        fu.setInput(ORIGINAL_WT_DATA_FILE);
        //fu.setInput(ORIGINAL_SUPP_DATA_FILE);
        FileUtility outputFu = new FileUtility();
        outputFu.setOutput(outFileName);
        String line = fu.readLine();
        outputFu.printLine(line);
        int original = 0;
        int filtered = 0;
        while ((line = fu.readLine()) != null) {
            String[] tokens = line.split("\t");
            original ++;
            // Gene name
            if (genes.contains(tokens[3])) {
                outputFu.printLine(line);
                filtered ++;
            }
        }
        outputFu.close();
        fu.close();
        System.out.println("Before filtering: " + original);
        System.out.println("After filtering: " + filtered);
    }
    
    /**
     * This method is used to get gene expression data
     */
    private Map<String, Integer> getGeneExpressionData() throws IOException {
        ExperimentalValidationTargetGenerator generator = new ExperimentalValidationTargetGenerator();
        return generator.generateGeneExpData();
    }
    
    @Test
    public void calcualteAverageShortestPathAsWhole() throws Exception {
        BreadthFirstSearch bfs = new BreadthFirstSearch();
        Set<String> fis = fu.loadInteractions(GENE_FI_BIG_COMP_FILE_NAME);
        Set<String> genes = InteractionUtilities.grepIDsFromInteractions(fis);
        Map<TreeNode, List<Edge>> geneToEdges = bfs.initGraph(fis);
        //List<String> validatedGenes = getValidatedGenes();
        List<String> validatedGenes = new RodBremnerArrayAnalyzer().loadDiffGenesFromFile();
        validatedGenes.retainAll(genes);
        System.out.println("Total validated genes: " + validatedGenes.size());
        Map<String, List<String>> pairToPath = bfs.generateShortestPath(validatedGenes,
                                                                        geneToEdges);
        int total = 0;
        for (String pair : pairToPath.keySet()) {
            total += pairToPath.get(pair).size() - 1;
        }
        double value = (double) total / pairToPath.size();
        System.out.println("Average shortest path: " + value);
    }
    
    /**
     * This method is used to calculate average shortest path between the proteins from Rod set and
     * the target genes (genes in the IFNG pathway).
     * @throws Exception
     */
    @Test
    public void calculateAveragePaths() throws Exception {
        boolean useShortestPath = true;
        BreadthFirstSearch bfs = new BreadthFirstSearch();
        Set<String> fis = fu.loadInteractions(GENE_FI_BIG_COMP_FILE_NAME);
        Set<String> fiGenes = InteractionUtilities.grepIDsFromInteractions(fis);
        Map<String, Set<String>> geneToPartners = bfs.generateIdToPartnersMap(fis);
        
        //Set<String> onePercentalGenes = getGenesFromDataFile(DATA_SET_DIR + "TOP1PercentalFromLOGCB.txt");
        //Set<String> candidateGenes = getGenesFromDataFile(DATA_SET_DIR + "TOP1PercentalFromLOGCB_Filter_Exp.txt");
        //Collection<String> candidateGenes = getValidatedGenes();
        //Collection<String> candidateGenes = getGenesFromDataFile(DATA_SET_DIR + "TOP1PercentalFromLOGCB.txt");
        Collection<String> candidateGenes = new RodBremnerArrayAnalyzer().loadDiffGenesFromFile();
        int originalSize = candidateGenes.size();
        System.out.println("Total candidate genes: " + candidateGenes.size());
        System.out.println("FI contains PIK3CD: " + fiGenes.contains("PIK3CD"));
        candidateGenes.retainAll(fiGenes);
        //System.out.println("candidate genes: " + candidateGenes);
        System.out.println("Gene not in the network: " + (originalSize - candidateGenes.size())); 
        //candidateGenes = MathUtilities.randomSampling(fiGenes, candidateGenes.size());
        List<String> checkingGenes = new ArrayList<String>(candidateGenes);
        List<String> targetGenes = getIFNGCoreComponents();
        targetGenes.retainAll(fiGenes);
        //List<String> targetGenes = getExtendardTargetGenes();
        System.out.println("checking genes: " + checkingGenes);
        checkingGenes.removeAll(targetGenes);
        System.out.println("Genes used for checking: " + checkingGenes.size());
        System.out.println("checking genes: " + checkingGenes);
        int totalPathLength = 0;
        int totalPath = 0;
        if (useShortestPath) {
            // Want to pick up the shortest path between the checking gene and all target genes
            for (String gene : checkingGenes) {
                Map<String, Integer> geneToPath = bfs.getDistances(gene, 
                                                                   targetGenes,
                                                                   geneToPartners);
                int currentPath = Integer.MAX_VALUE;
                for (String target : geneToPath.keySet()) {
                    Integer path = geneToPath.get(target);
                    if (path < currentPath)
                        currentPath = path;
                }
                System.out.println("path for " + gene + ": " + currentPath);
                totalPathLength += currentPath;
                totalPath ++;
            }
        }
        else {
            // Want to pick up all shortest paths between the checking gene and all target genes
            for (String gene : checkingGenes) {
                Map<String, Integer> geneToPath = bfs.getDistances(gene, 
                                                                   targetGenes,
                                                                   geneToPartners);
                for (String target : geneToPath.keySet()) {
                    Integer path = geneToPath.get(target);
                    System.out.println(gene + " " + target +": " + path);
                    totalPath ++;
                    totalPathLength += path;
                }
            }
        }
        System.out.println("Total path: " + totalPath);
        System.out.println("Average shortest path: " + totalPathLength / (double)totalPath);
        System.out.println("Total FI genes: " + fiGenes.size());
    }
    
    /**
     * Check the shortest path to see if they have been contained by some gene list.
     * @throws IOException
     */
    @Test
    public void analyzeShortestPath() throws Exception {
        BreadthFirstSearch bfs = new BreadthFirstSearch();
        Set<String> fis = fu.loadInteractions(GENE_FI_BIG_COMP_FILE_NAME);
        Set<String> genes = InteractionUtilities.grepIDsFromInteractions(fis);
        Map<TreeNode, List<Edge>> geneToEdges = bfs.initGraph(fis);
        List<String> validatedGenes = getValidatedGenes();
        validatedGenes.retainAll(genes);
        System.out.println("Total validated genes: " + validatedGenes.size());
        // Get the targets
        List<String> targetGenes = getIFNGCoreComponents();
        validatedGenes.removeAll(targetGenes);
        System.out.println("After target removing: " + validatedGenes.size());
        Set<String> genesInPath = new HashSet<String>();
        for (String target : targetGenes) {
            for (String validated: validatedGenes) {
                List<String> path = bfs.generateShortestPath(target, 
                                                             validated, 
                                                             geneToEdges);
                // Get the listed genes
                for (int i = 1; i < path.size() - 1; i++)
                    genesInPath.add(path.get(i));
            }
        }
        System.out.println("Total genes in path: " + genesInPath.size());
        // Check what percentage of these genes in the top 5 percentile genes
        List<String> topPercentileGenes = getTopPercentileGenes(false);
        List<String> copy = new ArrayList<String>(genesInPath);
        copy.retainAll(topPercentileGenes);
        double percent = (double) copy.size() / genesInPath.size();
        double pvalue = MathUtilities.calculateHypergeometricPValue(genes.size(), 
                                                                    topPercentileGenes.size(),
                                                                    genesInPath.size(),
                                                                    copy.size());
        System.out.printf("In top percent genes %d, percentile %f, p-value %f%n",
                          copy.size(),
                          percent,
                          pvalue);
        List<String> lowerPercentileGenes = getTopPercentileGenes(true);
        copy = new ArrayList<String>(genesInPath);
        copy.retainAll(lowerPercentileGenes);
        percent = (double) copy.size() / genesInPath.size();
        pvalue = MathUtilities.calculateHypergeometricPValue(genes.size(), 
                                                                    lowerPercentileGenes.size(),
                                                                    genesInPath.size(),
                                                                    copy.size());
        System.out.printf("In lower percent genes %d, percentile %f, p-value %f%n",
                          copy.size(),
                          percent,
                          pvalue);
        // Check how many genes in the validated list
        copy = new ArrayList<String>(genesInPath);
        copy.retainAll(getValidatedGenes());
        percent = (double) copy.size() / genesInPath.size();
        pvalue = MathUtilities.calculateHypergeometricPValue(genes.size(), 
                                                             getValidatedGenes().size(),
                                                             genesInPath.size(),
                                                             copy.size());
        System.out.printf("In validated genes %d, percentile %f, p-value %f%n",
                          copy.size(),
                          percent,
                          pvalue);
    }
    
    private List<String> getTopPercentileGenes(boolean isLowerTail) throws IOException {
        String fileName = DATA_SET_DIR + "WTFilterBasedFIs091708.txt";
        System.out.println("File: " + fileName);
        List<RowData> data = getRowData(fileName);
        Collections.sort(data, new Comparator<RowData>() {
            public int compare(RowData datum1, 
                               RowData datum2) {
                Double value1 = datum1.controlBased;
                Double value2 = datum2.controlBased;
                return value1.compareTo(value2);
            }
        });
        // Prepare fixed numbers
        int total = data.size();
        Set<String> totalGenes = new HashSet<String>();
        for (RowData row : data)
            totalGenes.add(row.gene);
        double percentile = 0.05;
        int recall = (int) (total * percentile);
        // Get the first 1%
        List<String> rtn = new ArrayList<String>();
        if (!isLowerTail) {
            for (int j = 0; j < recall; j++) {
                RowData datum = data.get(j);
                rtn.add(datum.gene);
            }
        }
        else {
            for (int j = total - 1; j >= total - 1 - recall; j--) {
                RowData datum = data.get(j);
                rtn.add(datum.gene);
            }
        }
        return rtn;
    }
    
    
    /**
     * A random test for average shortest path.
     * @throws Exception
     */
    @Test
    public void averageShortestPathTest() throws Exception {
        boolean useShortestPath = true;
        BreadthFirstSearch bfs = new BreadthFirstSearch();
        Set<String> fis = fu.loadInteractions(GENE_FI_BIG_COMP_FILE_NAME);
        Set<String> fiGenes = InteractionUtilities.grepIDsFromInteractions(fis);
        Map<String, Set<String>> geneToPartners = bfs.generateIdToPartnersMap(fis);
        
        List<Double> allPaths = new ArrayList<Double>();
        int permutation = 1000;
        int sampleSize = 11;
        List<String> targetGenes = getIFNGCoreComponents();
        targetGenes.retainAll(fiGenes);
        for (int i = 0; i < permutation; i++) {
            Collection<String> candidateGenes = MathUtilities.randomSampling(fiGenes, 
                                                                             sampleSize);
            candidateGenes.removeAll(targetGenes);
            if (candidateGenes.size() < sampleSize) {
                i --; // Make sure we get enough permutation
                continue;
            }
            List<String> checkingGenes = new ArrayList<String>(candidateGenes);
            int totalPathLength = 0;
            int totalPath = 0;
            if (useShortestPath) {
                for (String gene : checkingGenes) {
                    Map<String, Integer> geneToPath = bfs.getDistances(gene, 
                                                                       targetGenes,
                                                                       geneToPartners);
                    int currentPath = Integer.MAX_VALUE;
                    for (String target : geneToPath.keySet()) {
                        Integer path = geneToPath.get(target);
                        if (path < currentPath)
                            currentPath = path;
                    }
                    totalPathLength += currentPath;
                    totalPath ++;
                }
            }
            else {
                // Want to pick up the shortest path between the checking gene and all target genes
                for (String gene : checkingGenes) {
                    Map<String, Integer> geneToPath = bfs.getDistances(gene, 
                                                                       targetGenes,
                                                                       geneToPartners);
                    for (String target : geneToPath.keySet()) {
                        Integer path = geneToPath.get(target);
                        totalPath ++;
                        totalPathLength += path;
                    }
                }
            }
            System.out.println("Total path: " + totalPath);
            double avePath = (double) totalPathLength / totalPath;
            allPaths.add(avePath);
            System.out.println(i + ":: Average shortest path: " + avePath);
            System.out.println("Total FI genes: " + fiGenes.size());
        }
        Collections.sort(allPaths);
        for (Double path : allPaths)
            System.out.println(path);
    }
    
    private Graph<String, DefaultEdge> createGraph() throws Exception {
        Session session = getSession();
        Set<Interaction> interactions = fetchAllInteractions(session);
        Set<String> fis = new HashSet<String>();
        Set<String> genes = new HashSet<String>();
        for (Interaction i : interactions) {
            Protein first = i.getFirstProtein();
            Protein second = i.getSecondProtein();
            String label1 = first.getLabel();
            String label2 = second.getLabel();
            int compare = label1.compareTo(label2);
            // Use tab to delimit since space may be used.
            if (compare < 0)
                fis.add(label1 + "\t" + label2);
            else if (compare > 0)
                fis.add(label2 + "\t" + label1);
            genes.add(label1);
            genes.add(label2);
        }
        GraphAnalyzer graphAnalzyer = new GraphAnalyzer();
        Graph<String, DefaultEdge> graph = JGraphTUtilities.createGraph(genes, fis);
        return graph;
    }
    
    /**
     * This method is used to list all FIs in the database. The predicated FIs have been filtered based
     * on the cutoff value.
     * @return
     * @throws Exception
     */
    public Set<Interaction> fetchAllInteractions(Session session) throws Exception {
        Query query = session.createQuery("FROM Interaction as i WHERE i.evidence.probability > ?");
        query.setDouble(0, R3Constants.CUT_OFF_VALUE);
        List list = query.list();
        Set<Interaction> set = new HashSet<Interaction>();
        for (Object o : list)
            set.add((Interaction)o);
        query = session.createQuery("FROM Interaction as i WHERE i.evidence is null");
        list = query.list();
        for (Object i : list) {
            Interaction tmp = (Interaction) i;
            set.add(tmp);
        }
        return set;
    }
    
    /**
     * This method is used to generate a short list based on control base
     * scores distribution.
     * @throws Exception
     */
    @Test
    public void filterDatasetBasedOnCBScores() throws Exception {
        //double upperCutoff = 1.344436d;
        //double lowerCutoff = -1.318664d;
        //fu.setInput(ORIGINAL_WT_DATA_FILE);
        double upperCutoff = 1.344436d;
        double lowerCutoff = -1.318664d;
        fu.setInput(DATA_SET_DIR + "WTFilterBasedGeneExp.txt");
        FileUtility outFu = new FileUtility();
        outFu.setOutput(DATA_SET_DIR + "TOP1PercentalFromLOGCB_Filter_Exp.txt");
        String line = fu.readLine();
        outFu.printLine(line);
        int totalLine = 0;
        while ((line = fu.readLine()) != null) {
            String[] tokens = line.split("\t");
            double logCB = Math.log(Double.parseDouble(tokens[6]));
            if (logCB >= upperCutoff ||
                logCB <= lowerCutoff) {
                outFu.printLine(line);
                totalLine ++;
            }
        }
        outFu.close();
        fu.close();
        System.out.println("Total left lines: " + totalLine);
    }
    
    /**
     * This method is used to generate score files based on FI partners to the validated genes.
     * @throws Exception
     */
    @Test
    public void generateScoreFilesBasedOnValidatedGenes() throws Exception {
        // Get the validated genes
        List<String> validatedGenes = getValidatedGenes();
        Set<String> fis = fu.loadInteractions(GENE_FI_BIG_COMP_FILE_NAME);
        Set<String> allGenes = InteractionUtilities.grepIDsFromInteractions(fis);
        System.out.println("Total validated genes: " + validatedGenes.size());
        validatedGenes.retainAll(allGenes);
        System.out.println("Validated genes in the biggest component: " + validatedGenes.size());
        // Get the FI partners for the validated genes
        Map<String, Set<String>> geneToPartners = new HashMap<String, Set<String>>();
        Map<String, Set<String>> partnerToGenes = new HashMap<String, Set<String>>();
        for (String validatedGene : validatedGenes) {
            Set<String> partners = queryFIPartnersFromFile(validatedGene,
                                                          fis);
            geneToPartners.put(validatedGene,
                               partners);
            for (String partner : partners) {
                Set<String> genes = partnerToGenes.get(partner);
                if (genes == null) {
                    genes = new HashSet<String>();
                    partnerToGenes.put(partner, genes);
                }
                genes.add(validatedGene);
            }
        }
        // Group all FI partners together
        Set<String> fiPartners = new HashSet<String>();
        for (String validatedGene : geneToPartners.keySet()) {
            Set<String> partners = geneToPartners.get(validatedGene);
            fiPartners.addAll(partners);
        }
        System.out.println("Total validated gene partners: " + fiPartners.size());
        String outFileName = DATA_SET_DIR + "Validated_FI_Interactors_WT_110408.txt";
        filterDatasetBasedOnGenes(fiPartners, 
                                  outFileName);
        // Pick up genes interacting with at least two validated genes
        Set<String> partnerWith2Hits = new HashSet<String>();
        Set<String> partnerWith3Hits = new HashSet<String>();
        for (String partner : partnerToGenes.keySet()) {
            Set<String> genes = partnerToGenes.get(partner);
            if (genes.size() > 1)
                partnerWith2Hits.add(partner);
            if (genes.size() > 2)
                partnerWith3Hits.add(partner);
        }
        System.out.println("Total partners interacting with at least two validated genes: " + partnerWith2Hits.size());
        outFileName = DATA_SET_DIR + "Validated_FI_Interactors_2_Hits_WT_110408.txt";
        filterDatasetBasedOnGenes(partnerWith2Hits, outFileName);
        System.out.println("Total partners interacting with at least three validated genes: " + partnerWith3Hits.size());
        outFileName = DATA_SET_DIR + "Validated_FI_Interactors_3_Hits_WT_110408.txt";
        filterDatasetBasedOnGenes(partnerWith3Hits, outFileName);
    }
    
    private Set<String> queryFIPartnersFromFile(String target,
                                                Set<String> fis) {
        Set<String> partners = new HashSet<String>();
        int index;
        String id1, id2;
        for (String fi : fis) {
            index = fi.indexOf("\t");
            id1 = fi.substring(0, index);
            id2 = fi.substring(index + 1);
            if (id1.equals(target))
                partners.add(id2);
            else if (id2.equals(target))
                partners.add(id1);
        }
        return partners;
    }
    
    
    /**
     * This method is used to generate a score file for pathway interactors.
     * @throws Exception
     */
    @Test
    public void generateScoreFilesForIFNGInteractors() throws Exception {
        //Set<String> interactors = generateIFNGPathwayInteractors(true, 
        //                                                         true);
        //List<String> interactors = getExtendardTargetGenes();
        //Set<String> interactors = generateIFNGPathwayPPIInteractors();
        Set<String> interactors = generateIFNGPathwayPPIInteractorsFromFiles();
        //List<String> knownGenes = getExtendardTargetGenes();
        //interactors.removeAll(knownGenes);
        //String fileName = DATA_SET_DIR + "FinalCombineddataBNCB_WT.txt";
        //String fileName = DATA_SET_DIR + "FinalCombineddataBNCB_SUPP.txt";
        //String fileName = DATA_SET_DIR + "WTFilterBasedGeneExp.txt";
        String fileName = DATA_SET_DIR + "WTFilterBasedFIs091708.txt";
        //String fileName = DATA_SET_DIR + "SUPPFilterBasedFIs091708.txt";
        //String fileName = DATA_SET_DIR + "WTFilterOnFIsAndExp102108.txt";
        fu.setInput(fileName);
        //String outputFileName = DATA_SET_DIR + "IFNGComponents_WT_091708.txt";
        //String outputFileName = DATA_SET_DIR + "IFNGInteractors_WT_070108_1.txt";
        //String outputFileName = DATA_SET_DIR + "IFNGInteractors_SUPP_091708.txt";
        //String outputFileName = DATA_SET_DIR + "IFNGInteractors_Predicated_73_WT.txt";
        //String outputFileName = DATA_SET_DIR + "IFNGInteractors_SUPP_ALL_PPI_070108.txt";
        //String outputFileName = DATA_SET_DIR + "IFNGInteractions_WT_GeneExp_Predicated.txt";
        //String outputFileName = DATA_SET_DIR + "IFNGInteractorsWithCompiledGenes_WT.txt";
        //String outputFileName = DATA_SET_DIR + "IFNGInteractorsWithCompiledGenes_SUPP_NOPI.txt";
        //String outputFileName = DATA_SET_DIR + "IFNG_ALL_PPI_Interactors_WT_091808.txt";
        //String outputFileName = DATA_SET_DIR + "IFNG_ALL_PPI_Interactors_SUPP_091808.txt";
        //String outputFileName = DATA_SET_DIR + "IFNGInteractors_WT_FILTER_GENE_EXP_102108.txt";
        //String outputFileName = DATA_SET_DIR + "IFNGInteractors_WT_102908.txt";
        String outputFileName = DATA_SET_DIR + "IFNG_ALL_PPI_Interactors_WT_102908.txt";
        FileUtility outputFu = new FileUtility();
        outputFu.setOutput(outputFileName);
        // The title
        String line = fu.readLine();
        outputFu.printLine(line);
        Set<String> genes = new HashSet<String>();
        int totalLine = 0;
        while ((line = fu.readLine()) != null) {
            String[] tokens = line.split("\t");
            String gene = tokens[3];
            if (interactors.contains(gene)) {
                outputFu.printLine(line);
                totalLine ++;
                //System.out.println(line);
            }
        }
        System.out.println("Picked lines: " + totalLine);
        fu.close();
        outputFu.close();
    }
    
    /**
     * Get the IFNG pathway core components in gene names.
     * @return
     * @throws Exception
     */
    private List<String> getIFNGCoreComponents() throws Exception {
        String[] queryGenes = new String[] {
                "STAT1",
                "IFNGR2",
                "IFNGR1",
                "JAK1",
                "JAK2",
                "SMARCA4",
                "SOCS1"
        };
        return Arrays.asList(queryGenes);
    }
    
    private Set<String> getIFNGFIPartnersFromFile(int level,
                                                  Set<String> fis) throws Exception {
        List<String> targets = getIFNGCoreComponents();
        int index = 0;
        Set<String> current = new HashSet<String>(targets);
        Set<String> next = new HashSet<String>();
        Set<String> checked = new HashSet<String>(current);
        for (int i = 0; i < level; i ++) {
            for (String fi : fis) {
                index = fi.indexOf("\t");
                String gene1 = fi.substring(0, index);
                String gene2 = fi.substring(index + 1);
                if (current.contains(gene1)) {
                    if (!checked.contains(gene2)) {
                        next.add(gene2);
                        checked.add(gene2);
                    }
                }
                else if (current.contains(gene2)) {
                    if (!checked.contains(gene1)) {
                        next.add(gene1);
                        checked.add(gene1);
                    }
                }
            }
            current.clear();
            current.addAll(next);
            next.clear();
        }
        checked.removeAll(targets);
        return checked;    
    }
    
    /**
     * The gene set in this method was compiled base on this review:
     * The following gene list was extracted from review:
     * Schroder, K et al. Interferon-gamma: an overview of signaling, mechanism and functions. 
     * J. Leuk Bio 75: 163-189 (2004)
     * @return
     * @throws Exception
     */
    private List<String> getExtendardTargetGenes() throws Exception {
        String fileName = DATA_SET_DIR + "CompiledGeneListForIFNG.txt";
        fu.setInput(fileName);
        List<String> geneNames = new ArrayList<String>();
        String line = null;
        while ((line = fu.readLine()) != null) {
            String[] ids = line.split("\t");
            geneNames.add(ids[1]);
        }
        fu.close();
        return geneNames;
    }
    
    /**
     * This method is used to generate a list of genes that can interact with pathway components
     * in the IFNG pathways.
     * @throws Exception
     */
    private Set<String> generateIFNGPathwayInteractors(boolean needPathway,
                                                       boolean needPredicated) throws Exception {
        List<String> queryGenes = getIFNGCoreComponents();
        return queryFIPartners(needPathway, needPredicated, queryGenes);
    }

    private Set<String> queryFIPartners(boolean needPathway,
                                        boolean needPredicated,
                                        List<String> queryGenes) throws Exception {
        Session session = getSession();
        Set<String> interactors = new HashSet<String>();
        //List<String> queryGenes = getExtendardTargetGenes();
        //queryGenes = getRandomGenes(queryGenes.size());
        for (String queryName : queryGenes) {
            Set<String> set = queryFIPartners(session,
                                              queryName,
                                              needPathway,
                                              needPredicated);
            if (set.contains("PIK3CD"))
                System.out.println(queryName + " -> PIK3CD");
            System.out.println("FI partners for " + queryName + ": " + set.size());
            interactors.addAll(set);
        }
        session.close();
        interactors.removeAll(queryGenes);
        System.out.println("Total pathway FI partners: " + interactors.size());
        return interactors;
    }
    
    /**
     * This method is used to generate PPI only interactors without considering
     * any scores.
     * @return
     * @throws Exception
     */
    private Set<String> generateIFNGPathwayPPIInteractors() throws Exception {
        Session session = getSession();
        Set<String> interactors = new HashSet<String>();
        List<String> queryGenes = getIFNGCoreComponents();
        //List<String> queryGenes = getExtendardTargetGenes();
        //queryGenes = getRandomGenes(queryGenes.size());
        for (String queryName : queryGenes) {
            Set<String> set = queryPPIPartners(session,
                                              queryName);
            System.out.println("PPI partners for " + queryName + ": " + set.size());
            interactors.addAll(set);
        }
        session.close();
        interactors.removeAll(queryGenes);
        System.out.println("Total pathway FI partners: " + interactors.size());
        return interactors;
    }
    
    private Set<String> generateIFNGPathwayPPIInteractorsFromFiles() throws Exception {
        Set<String> allPPIs = loadPPIsFromFiles();
        List<String> queryGenes = getIFNGCoreComponents();
        Set<String> interactors = new HashSet<String>();
        for (String queryName : queryGenes) {
            Set<String> set = queryPPIPartnersFromFiles(allPPIs, queryName);
            System.out.println("PPI partners for " + queryName + ": " + set.size());
            interactors.addAll(set);
        }
        interactors.removeAll(queryGenes);
        System.out.println("Total pathway FI partners: " + interactors.size());
        return interactors;
    }
    
    private Set<String> loadPPIsFromFiles() throws Exception {
        String[] ppiFileNames = new String[] {
                "BINDInteractions020507.txt",
                "IntActInteractions020507.txt",
                "HPRDInteractions020507.txt",
        };
        Set<String> humanInteractions = new HashSet<String>();
        for (String ppi : ppiFileNames) {
            Set<String> set = null;
            set = fu.loadInteractions(R3Constants.RESULT_DIR + ppi);
            humanInteractions.addAll(set);
        }
        // UniProtAnalyzer is used to filter
        UniProtAnalyzer uniAnalyzer = new UniProtAnalyzer();
        Map<String, String> uniIdMap = uniAnalyzer.loadUniProtIDsMap();
        Set<String> uniSet = uniIdMap.keySet();
        // For sequence handler
        ProteinSequenceHandler seqHandler = new ProteinSequenceHandler();
        // Do some filters for PPIs
        FunctionalInteractionAnalyzer fiAnalyzer = new FunctionalInteractionAnalyzer();
        fiAnalyzer.setUp();
        fiAnalyzer.filterNonHumanIds(humanInteractions, uniSet, uniAnalyzer);
        humanInteractions = fiAnalyzer.filterRedundencyInteractions(humanInteractions, uniIdMap);
        humanInteractions = seqHandler.consolidateInteractionsUseChecksum(humanInteractions);
        // Need to map to protein names
        HibernateFIReader hiFiAnalyzer = new HibernateFIReader();
        Map<String, String> idToName = hiFiAnalyzer.generateAccessionToProteinNames();
        Set<String> rtn = new HashSet<String>();
        int index = 0;
        for (String ppi : humanInteractions) {
            index = ppi.indexOf(" ");
            String p1 = ppi.substring(0, index);
            String p2 = ppi.substring(index + 1);
            String name1 = idToName.get(p1);
            String name2 = idToName.get(p2);
            int compare = name1.compareTo(name2);
            if (compare < 0)
                rtn.add(name1 + "\t" + name2);
            else if (compare > 0)
                rtn.add(name2 + "\t" + name1);
        }
        return rtn;
    }
    
    @Test
    public void testLoadPPIsFromFiles() throws Exception {
        Set<String> ppis = loadPPIsFromFiles();
        System.out.println("PPIs: " + ppis.size());
    }
    
    
    private Set<String> queryPPIPartnersFromFiles(Set<String> ppis,
                                                 String queryName) {
        Set<String> partners = new HashSet<String>();
        int index = 0;
        for (String ppi : ppis) {
            index = ppi.indexOf("\t");
            String name1 = ppi.substring(0, index);
            String name2 = ppi.substring(index + 1);
            if (name1.equals(queryName))
                partners.add(name2);
            else if (name2.equals(queryName))
                partners.add(name1);
        }
        return partners;
    }
                                                 
    
    private Set<String> queryPPIPartners(Session session,
                                        String queryName) {
        Query query1 = session.createQuery("FROM Interaction as i WHERE i.firstProtein.shortName = ?");
        query1.setParameter(0, queryName);
        List list = query1.list();
        Set<Interaction> interactions = new HashSet<Interaction>();
        for (Iterator it = list.iterator(); it.hasNext();) {
            Interaction i = (Interaction) it.next();
            interactions.add(i);
        }
        Query query2 = session.createQuery("FROM Interaction as i WHERE i.secondProtein.shortName = ?");
        query2.setParameter(0, queryName);
        list = query2.list();
        for (Iterator it = list.iterator(); it.hasNext();) {
            Interaction i = (Interaction) it.next();
            interactions.add(i);
        }
        // Do some filtering
        for (Iterator<Interaction> it = interactions.iterator(); it.hasNext();) {
            Interaction interaction = it.next();
            if (interaction.getEvidence() == null) {
                it.remove();
                continue;
            }
            Evidence evidence = interaction.getEvidence();
            Boolean humanPPI = evidence.getHumanInteraction();
            if (humanPPI == null)
                humanPPI = false;
            Boolean orthPPI = evidence.getOrthoInteraction();
            if (orthPPI == null)
                orthPPI = false;
            if (!humanPPI && !orthPPI)
                it.remove();
        }
        // Get the partners
        Set<String> partners = new HashSet<String>();
        for (Interaction i : interactions) {
            // The following check is used to get pure predicated FIs only.
            //if (i.getEvidence() == null ||
            //    i.getEvidence().getProbability() >= CUT_OFF) {
                Protein first = i.getFirstProtein();
                Protein second = i.getSecondProtein();
                if (first.getLabel().equals(queryName)) {
                    partners.add(second.getLabel());    
                }
                else 
                    partners.add(first.getLabel());
           // }
        }
        return partners;
    }
    
    private List<String> getRandomGenes(int number) throws IOException {
        List<String> genes = new ArrayList<String>(number);
        Set<String> allGenes = getGenesFromDataFile(DATA_SET_DIR + "SUPPFilterBasedFIs.txt");
        List<String> allList = new ArrayList<String>(allGenes);
        while (genes.size() < number) {
            int index = (int) (Math.random() * allList.size());
            genes.add(allList.get(index));
        }
        return genes;
    }
    
    private Set<String> queryFIPartners(Session session,
                                       String queryName,
                                       boolean needPathway,
                                       boolean needPredicated) throws Exception {
        Query query1 = session.createQuery("FROM Interaction as i WHERE i.firstProtein.shortName = ?");
        query1.setParameter(0, queryName);
        List list = query1.list();
        Set<Interaction> interactions = new HashSet<Interaction>();
        for (Iterator it = list.iterator(); it.hasNext();) {
            Interaction i = (Interaction) it.next();
            interactions.add(i);
        }
        Query query2 = session.createQuery("FROM Interaction as i WHERE i.secondProtein.shortName = ?");
        query2.setParameter(0, queryName);
        list = query2.list();
        for (Iterator it = list.iterator(); it.hasNext();) {
            Interaction i = (Interaction) it.next();
            interactions.add(i);
        }
        // Filter based on passed parameters
        if (!needPathway) {
            for (Iterator<Interaction> it = interactions.iterator(); it.hasNext();) {
                Interaction i = it.next();
                if (i.getEvidence() == null)
                    it.remove();
            }
        }
        if (!needPredicated) {
            for (Iterator<Interaction> it = interactions.iterator(); it.hasNext();) {
                Interaction i = it.next();
                if (i.getEvidence() != null)
                    it.remove();
            }
        }
        // Get the partners
        Set<String> partners = new HashSet<String>();
        for (Interaction i : interactions) {
            Set<ReactomeSource> sources = i.getReactomeSources();
            if (i.getEvidence() == null ||
                i.getEvidence().getProbability() >= CUT_OFF) {
                Protein first = i.getFirstProtein();
                Protein second = i.getSecondProtein();
                if (first.getLabel().equals(queryName)) {
                    partners.add(second.getLabel());    
                }
                else 
                    partners.add(first.getLabel());
            }
        }
        return partners;
    }
    
    /**
     * This method is used to check how many genes in the data set list
     * can be mapped to proteins used in the FI network via the hibernate
     * API.
     * @throws Exception
     */
    @Test
    public void checkGeneSymbolCoverageViaFIDB() throws Exception {
        Set<String> fiGenes = fetchGenesInFINetwork();
        System.out.println("Total protein names: " + fiGenes.size());
        Set<String> checkedGenes = getGenesFromDataFile(ORIGINAL_WT_DATA_FILE);
        System.out.println("Genes in the data set: " + checkedGenes.size());
        fiGenes.retainAll(checkedGenes);
        System.out.println("Genes in the data set and in the FI database: " + fiGenes.size());
    }
    
    /**
     * This method is used to check how many genes listed in the original
     * data set can be mapped to UniProt based on the mapping file.
     * @throws Exception
     */
    @Test
    public void checkGeneSymbolToUniProtConversion() throws Exception {
        UniProtAnalyzer uniProtAnalyzer = new UniProtAnalyzer();
        Map<String, String> geneToUniProt = uniProtAnalyzer.loadGeneNameToUniProt();
        String fileName = DATA_SET_DIR + "FinalCombineddataBNCB_WT.txt";
        fu.setInput(fileName);
        // The title
        String line = fu.readLine();
        int totalGene = 0;
        int mappable = 0;
        while ((line = fu.readLine()) != null) {
            String[] tokens = line.split("\t");
            String gene = tokens[3];
            totalGene ++;
            String uniProt = geneToUniProt.get(gene);
            if (uniProt != null)
                mappable ++;
        }
        System.out.println("Total genes: " + totalGene);
        System.out.println("Mappable: " + mappable);
    }
    
    private Set<String> getGenesFromDataFile(String fileName) throws IOException {
        fu.setInput(fileName);
        // The title
        String line = fu.readLine();
        Set<String> genes = new HashSet<String>();
        while ((line = fu.readLine()) != null) {
            String[] tokens = line.split("\t");
            String gene = tokens[3];
            genes.add(gene);
        }
        return genes;
    }
    
    /**
     * This method is used to check the overlapping between the FI partners
     * and the first or last percentile genes based on several different 
     * scores.
     * @throws Exception
     */
    @Test
    public void checkDistributionsBasedOnPercentile() throws Exception {
        //String fileName = DATA_SET_DIR + "SUPPFilterBasedFIs091708.txt";
        String fileName = DATA_SET_DIR + "WTFilterBasedFIs091708.txt";
        System.out.println("File: " + fileName);
        List<RowData> data = getRowData(fileName);
        Collections.sort(data, new Comparator<RowData>() {
            public int compare(RowData datum1, 
                               RowData datum2) {
                Double value1 = datum1.controlBased;
                Double value2 = datum2.controlBased;
                return value1.compareTo(value2);
            }
        });
        // Prepare fixed numbers
        int total = data.size();
        // Get the FI partners
        Set<String> fiPartners = generateIFNGPathwayInteractors(true, true);
        //Set<String> fiPartners = generateIFNGPathwayPPIInteractorsFromFiles();
        //Set<String> fiPartners = generateIFNGPathwayPPIInteractors();
        //List<String> fiPartners = getExtendardTargetGenes();
        // Get the total genes
        Set<String> totalGenes = new HashSet<String>();
        for (RowData row : data)
            totalGenes.add(row.gene);
        totalGenes.removeAll(getIFNGCoreComponents()); // Have to exclude these known target genes
        fiPartners.retainAll(totalGenes);
        System.out.println("Total FI partners: " + fiPartners.size());
        // Check different percentile
        StringBuilder builder = new StringBuilder();
        builder.append("Percentile\tLowerTailGenes\tLowerTailShared\tLowerTailP_value\tUpperTailGenes\tUpperTailShared\tUpperTailP_Value");
        for (int i = 0; i < 50; i++) {
            builder.append("\n");
            double percentile = 0.01 * (i + 1);
            builder.append(percentile);
            int recall = (int) (total * percentile);
            // Get the first 1%
            List<String> lowerTail = new ArrayList<String>();
            for (int j = 0; j < recall; j++) {
                RowData datum = data.get(j);
                lowerTail.add(datum.gene);
            }
            builder.append("\t").append(lowerTail.size());
            List<String> upperTail = new ArrayList<String>();
            for (int j = total - 1; j >= total - 1 - recall; j--) {
                RowData datum = data.get(j);
                upperTail.add(datum.gene);
            }
            Set<String> copy = new HashSet<String>(fiPartners);
            copy.retainAll(lowerTail);
            builder.append("\t").append(copy.size());
            double pvalue = MathUtilities.calculateHypergeometricPValue(totalGenes.size(), 
                                                                        lowerTail.size(),
                                                                        fiPartners.size(),
                                                                        copy.size());
            builder.append("\t").append(pvalue);
            builder.append("\t").append(upperTail.size());
            copy = new HashSet<String>(fiPartners);
            copy.retainAll(upperTail);
            builder.append("\t").append(copy.size());
            pvalue = MathUtilities.calculateHypergeometricPValue(totalGenes.size(), 
                                                                 upperTail.size(),
                                                                 fiPartners.size(),
                                                                 copy.size());
            builder.append("\t").append(pvalue);
        }
        System.out.println(builder.toString());
    }
    
    private List<RowData> getRowData(String fileName) throws IOException {
        List<RowData> data = new ArrayList<RowData>();
        fu.setInput(fileName);
        String line = fu.readLine();
        while ((line = fu.readLine()) != null) {
            String[] tokens = line.split("\t");
            String gene = tokens[3];
            String controlBased = tokens[6];
            RowData datum = new RowData();
            datum.gene = gene;
            datum.controlBased = Double.parseDouble(controlBased);
            datum.bScore = Double.parseDouble(tokens[4]);
            datum.mScore = Double.parseDouble(tokens[5]);
            data.add(datum);
        }
        fu.close();
        return data;
    }
    
    /**
     * This method is used to count genes in the data file
     * @throws IOException
     */
    @Test
    public void countGenesInDataFile() throws IOException {
        Map<String, Integer> geneList = new HashMap<String, Integer>();
        Map<String, Integer> catalogList = new HashMap<String, Integer>();
        Map<String, Set<String>> catalogToGenes = new HashMap<String, Set<String>>();
        Map<String, Set<String>> geneToCatalogs = new HashMap<String, Set<String>>();
        String fileName = ORIGINAL_WT_DATA_FILE;
        fu.setInput(fileName);
        String line = fu.readLine();
        while ((line = fu.readLine()) != null) {
            String[] tokens = line.split("\t");
            String gene = tokens[3];
            Integer count = geneList.get(gene);
            if (count == null)
                geneList.put(gene, 1);
            else {
                geneList.put(gene, ++count);
            }
            String catalog = tokens[28];
            count = catalogList.get(catalog);
            if (count == null)
                catalogList.put(catalog, 1);
            else
                catalogList.put(catalog, ++count);
            // Register these values
            Set<String> catalogs = geneToCatalogs.get(gene);
            if (catalogs == null) {
                catalogs = new HashSet<String>();
                geneToCatalogs.put(gene, catalogs);
            }
            catalogs.add(catalog);
            Set<String> genes = catalogToGenes.get(catalog);
            if (genes == null) {
                genes = new HashSet<String>();
                catalogToGenes.put(catalog, genes);
            }
            genes.add(gene);
        }
        System.out.println("Genes: " + geneList.size());
        System.out.println("Catalogs: " + catalogList.size());
        // Want to find the duplication ones
        // Find duplicated genes
        System.out.println("Genes duplicated:");
        for (String gene : geneList.keySet()) {
            Integer count = geneList.get(gene);
            if (count > 1) {
                // get the catalogs
                Set<String> catalogs = geneToCatalogs.get(gene);
                System.out.println(gene + "\t" + catalogs);
            }
        }
        System.out.println("Catalog duplicated:");
        for (String catalog : catalogList.keySet()) {
            Integer count = catalogList.get(catalog);
            if (count > 1) {
                // Get the genes
                Set<String> genes = catalogToGenes.get(catalog);
                System.out.println(catalog + "\t" + genes);
            }
        }
    }
    
    private class RowData {
        String gene;
        double bScore;
        double mScore;
        double controlBased;
    }
    
}
